{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Retos con TdR STEAM y UNO \u00b6 Lo que vamos a necesitar \u00b6 Software \u00b6 Para llevar a cabo la programaci\u00f3n de los retos es necesario estar registrado en ArduinoBlocks y se recomienda hacerlo con el nombre real para posteriormente facilitar la localizaci\u00f3n si es necesaria. La tarea es sencilla y est\u00e1 perfectamente descrita en el Free Book (online & updated) que podemos encontrar en los recursos de la plataforma www.arduinoblocks.com . Creamos un \"nuevo usuario\" utilizando para ello una cuenta de correo v\u00e1lida donde vamos a recibir un correo de confirmaci\u00f3n para activarla. Ya estamos en condiciones de crear nuestros propios proyectos en la plataforma como veremos mas adelante. Crear un nuevo proyecto Descarga e instala en tu ordenador y para tu sistema operativo ArduinoBlocks - Connector . Este programa vamos a necesitarlo para poder comunicar nuestra placa con la plataforma a trav\u00e9s del puerto USB de nuestro ordenador. Hardware imprescindible \u00b6 Una placa Imagina TdR STEAM versi\u00f3n 2.0 como la de la imagen siguiente: Shield TdR-STEAM V2.0 Una placa tipo Arduino UNO R3, o bien alguna de las desarrolladas por ser hardware libre como estas de Keyestudio . Ks0341 - Placa avanzada Keyestudio UNO Compatible Ks0172 - Placa Keyestudio UNO con conectores de 3 pines Hardware recomendado \u00b6 A continuaci\u00f3n exponemos el material adicional que vamos a emplear en esta colecci\u00f3n de retos que no es otro que el incluido en el Kit Imagina TdR STEAM comercializado por la empresa INNOVA DIDACTIC . Mando de control remoto por infrarojos para utilizar en conjunto con el sensor de infrarojos integrado en la placa TdR-STEAM. Mando a distancia por IR Pantalla LCD 1602 IIC (I2C) de 2 l\u00ednea de 16 caracteres. Nos va a permitir mostrar mensajes de texto e ir\u00e1 conectada al conector I2C de la placa TdR-STEAM. LCD 1602 I2C Sensor de sonido anal\u00f3gico (con potenciometro). Se utiliza b\u00e1sicamente para detectar el nivel sonoro ambiental. El potenciometro permite ajustar el nivel de ganancia. Sensor de sonido anal\u00f3gico","title":"Introducci\u00f3n"},{"location":"#retos-con-tdr-steam-y-uno","text":"","title":"Retos con TdR STEAM y UNO"},{"location":"#lo-que-vamos-a-necesitar","text":"","title":"Lo que vamos a necesitar"},{"location":"#software","text":"Para llevar a cabo la programaci\u00f3n de los retos es necesario estar registrado en ArduinoBlocks y se recomienda hacerlo con el nombre real para posteriormente facilitar la localizaci\u00f3n si es necesaria. La tarea es sencilla y est\u00e1 perfectamente descrita en el Free Book (online & updated) que podemos encontrar en los recursos de la plataforma www.arduinoblocks.com . Creamos un \"nuevo usuario\" utilizando para ello una cuenta de correo v\u00e1lida donde vamos a recibir un correo de confirmaci\u00f3n para activarla. Ya estamos en condiciones de crear nuestros propios proyectos en la plataforma como veremos mas adelante. Crear un nuevo proyecto Descarga e instala en tu ordenador y para tu sistema operativo ArduinoBlocks - Connector . Este programa vamos a necesitarlo para poder comunicar nuestra placa con la plataforma a trav\u00e9s del puerto USB de nuestro ordenador.","title":"Software"},{"location":"#hardware-imprescindible","text":"Una placa Imagina TdR STEAM versi\u00f3n 2.0 como la de la imagen siguiente: Shield TdR-STEAM V2.0 Una placa tipo Arduino UNO R3, o bien alguna de las desarrolladas por ser hardware libre como estas de Keyestudio . Ks0341 - Placa avanzada Keyestudio UNO Compatible Ks0172 - Placa Keyestudio UNO con conectores de 3 pines","title":"Hardware imprescindible"},{"location":"#hardware-recomendado","text":"A continuaci\u00f3n exponemos el material adicional que vamos a emplear en esta colecci\u00f3n de retos que no es otro que el incluido en el Kit Imagina TdR STEAM comercializado por la empresa INNOVA DIDACTIC . Mando de control remoto por infrarojos para utilizar en conjunto con el sensor de infrarojos integrado en la placa TdR-STEAM. Mando a distancia por IR Pantalla LCD 1602 IIC (I2C) de 2 l\u00ednea de 16 caracteres. Nos va a permitir mostrar mensajes de texto e ir\u00e1 conectada al conector I2C de la placa TdR-STEAM. LCD 1602 I2C Sensor de sonido anal\u00f3gico (con potenciometro). Se utiliza b\u00e1sicamente para detectar el nivel sonoro ambiental. El potenciometro permite ajustar el nivel de ganancia. Sensor de sonido anal\u00f3gico","title":"Hardware recomendado"},{"location":"3D/","text":"Caja contenedor imprimible 3D \u00b6 Partes \u00b6 La caja est\u00e1 compuesta de una base, una tapa, tres tornillos y un destornillador. La base con indicaci\u00f3n de donde va a ir cada elemento la vemos en la imagen siguiente: Base o caja El aspecto de la tapa lo tenemos en la imagen siguiente, donde podemos observar el orificio estriado que servir\u00e1 para colocar el destornillador cuando finalicemos el montaje. Tapa Finalmente en la imagen siguiente podemos ver el aspecto de uno de los tres tornillos que sujetan la tapa a la caja y el del destornillador. Tornillo y destornillador Archivos stl listos para descargar e imprimir \u00b6 Archivo STL de la caja: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip Pasos de montaje \u00b6 Paso 1 . Colocamos la TdR STEAM sobre la placa UNO pasando el cable de cuatro hilos entre ambas y colocando el conector JST de 4 pines en la TdR STEAM (este conector solamente entra en una posici\u00f3n) para obtener algo similar a la imagen siguiente: Montaje de la TdR STEAM sobre UNO conectando el I2C Paso 2 . Conectamos la LCD mediante el conector plano de 4 pines asegurando que el cable negro va al pin marcado como GND. Hay que tener precauci\u00f3n con la orientaci\u00f3n de este conector pues es reversible. El resultado debe ser similar al siguiente: Montaje de la LCD Paso 3 . En la imagen siguiente se ven los elementos anteriores colocados en su lugar. Montaje de Shield+UNO y LCD en la base Paso 4 . Conectamos un cable de tres hilos al micr\u00f3fono teniendo en cuenta que el cable negro va al terminal marcado con una G y el otro extremo del cable lo colocamos en el conector JST de 3 pines marcado con A3. Pasamos los cables por debajo de la LCD y el resultado ser\u00e1 algo similar a lo siguiente: Montaje de micr\u00f3fono Paso 5 . Colocamos el teclado en su lugar. Colocaci\u00f3n del mando a distancia Paso 6 . Finalmente colocamos la tapa y atornillamos cada tornillo en su tuerca, los apretamos con ayuda del destornillador y colocamos este en su alojamiento. Tendremos finalizada la colocaci\u00f3n de elementos en la caja, tal y como vemos a continuaci\u00f3n: Montaje finalizado","title":"Elementos impresi\u00f3n 3D"},{"location":"3D/#caja-contenedor-imprimible-3d","text":"","title":"Caja contenedor imprimible 3D"},{"location":"3D/#partes","text":"La caja est\u00e1 compuesta de una base, una tapa, tres tornillos y un destornillador. La base con indicaci\u00f3n de donde va a ir cada elemento la vemos en la imagen siguiente: Base o caja El aspecto de la tapa lo tenemos en la imagen siguiente, donde podemos observar el orificio estriado que servir\u00e1 para colocar el destornillador cuando finalicemos el montaje. Tapa Finalmente en la imagen siguiente podemos ver el aspecto de uno de los tres tornillos que sujetan la tapa a la caja y el del destornillador. Tornillo y destornillador","title":"Partes"},{"location":"3D/#archivos-stl-listos-para-descargar-e-imprimir","text":"Archivo STL de la caja: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip","title":"Archivos stl listos para descargar e imprimir"},{"location":"3D/#pasos-de-montaje","text":"Paso 1 . Colocamos la TdR STEAM sobre la placa UNO pasando el cable de cuatro hilos entre ambas y colocando el conector JST de 4 pines en la TdR STEAM (este conector solamente entra en una posici\u00f3n) para obtener algo similar a la imagen siguiente: Montaje de la TdR STEAM sobre UNO conectando el I2C Paso 2 . Conectamos la LCD mediante el conector plano de 4 pines asegurando que el cable negro va al pin marcado como GND. Hay que tener precauci\u00f3n con la orientaci\u00f3n de este conector pues es reversible. El resultado debe ser similar al siguiente: Montaje de la LCD Paso 3 . En la imagen siguiente se ven los elementos anteriores colocados en su lugar. Montaje de Shield+UNO y LCD en la base Paso 4 . Conectamos un cable de tres hilos al micr\u00f3fono teniendo en cuenta que el cable negro va al terminal marcado con una G y el otro extremo del cable lo colocamos en el conector JST de 3 pines marcado con A3. Pasamos los cables por debajo de la LCD y el resultado ser\u00e1 algo similar a lo siguiente: Montaje de micr\u00f3fono Paso 5 . Colocamos el teclado en su lugar. Colocaci\u00f3n del mando a distancia Paso 6 . Finalmente colocamos la tapa y atornillamos cada tornillo en su tuerca, los apretamos con ayuda del destornillador y colocamos este en su alojamiento. Tendremos finalizada la colocaci\u00f3n de elementos en la caja, tal y como vemos a continuaci\u00f3n: Montaje finalizado","title":"Pasos de montaje"},{"location":"IoT_basico/","text":"Teor\u00eda b\u00e1sica de IoT \u00b6 1.- \u00bfQu\u00e9 es la Internet de las Cosas? \u00b6 La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000 2.- M\u00f3dulo ESP8266 ESP-01 \u00b6 Introducci\u00f3n \u00b6 El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C. Programaci\u00f3n \u00b6 El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar. 3.- Comando AT en el ESP8266 \u00b6 El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT 4.- Preparaci\u00f3n del m\u00f3dulo ESP-01 \u00b6 Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 . 5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT \u00b6 Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concreto o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida. 6.- Creaci\u00f3n de un canal en un servidor MQTT \u00b6 En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak 7.- Filtrado por MAC \u00b6 Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#teoria-basica-de-iot","text":"","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#1-que-es-la-internet-de-las-cosas","text":"La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000","title":"1.- \u00bfQu\u00e9 es la Internet de las Cosas?"},{"location":"IoT_basico/#2-modulo-esp8266-esp-01","text":"","title":"2.- M\u00f3dulo ESP8266 ESP-01"},{"location":"IoT_basico/#introduccion","text":"El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.","title":"Introducci\u00f3n"},{"location":"IoT_basico/#programacion","text":"El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar.","title":"Programaci\u00f3n"},{"location":"IoT_basico/#3-comando-at-en-el-esp8266","text":"El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT","title":"3.- Comando AT en el ESP8266"},{"location":"IoT_basico/#4-preparacion-del-modulo-esp-01","text":"Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 .","title":"4.- Preparaci\u00f3n del m\u00f3dulo ESP-01"},{"location":"IoT_basico/#5-una-introduccion-al-iot-a-traves-de-mqtt","text":"Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concreto o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida.","title":"5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT"},{"location":"IoT_basico/#6-creacion-de-un-canal-en-un-servidor-mqtt","text":"En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak","title":"6.- Creaci\u00f3n de un canal en un servidor MQTT"},{"location":"IoT_basico/#7-filtrado-por-mac","text":"Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"7.- Filtrado por MAC"},{"location":"R01/","text":"Reto-01. LED \u00b6 Enunciado \u00b6 Realizar un programa que encienda y apague el LED rojo conectado al pin D12. Teor\u00eda \u00b6 El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energia Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores En la TdR STEAM \u00b6 La placa Imagina TDR STEAM dispone de un LED rojo conectado al pin D12 tal y como se indica en la serigrafia de la propia placa y que podemos ver en la imagen siguiente: LED rojo en la TdR STEAM Programando el reto \u00b6 Entramos en ArduinoBlocks y nos identificamos convenientemente. Vamos a crear un nuevo proyecto para la placa TdR STEAM siguiendo el procedimiento que vemos en la siguiente animaci\u00f3n: Escogemos el bloque LED de TDR STEAM y lo colocamos en el bucle, quedando algo similar a la imagen siguiente: Bloque LED de TDR STEAM Podemos comprobar haciendo clic sobre las flechas como podemos cambiar de LED y tambi\u00e9n como podemos cambiar de estado al LED. Si solamente dejamos este bloque el LED permanecer\u00e1 encendido de forma permanente y para que se acabe debemos ponerlo en estado OFF. En la imagen siguiente vemos el programa como quedar\u00eda. LED D12 a ON y OFF Pero este programa no nos permite ver el efecto de encendido y apagado del LED debido a la velocidad de procesamiento que tiene la placa UNO que tipicamente trabaja a 16 MHz. Esto supone que el micro tarda en ejecutar una instrucci\u00f3n algo mas de 0,06 microsegundos que es mucho menor que la persistencia visual humana de 0,1 segundo aproximadamente. Es decir, en realidad el LED se enciende y se apaga, pero nuestro ojo no puede apreciarlo y lo ver\u00e1 siempre encendido debido a la persistencia visual. Tenemos por tanto que dejar el diodo un tiempo encendido y otro apagado (pueden ser el mismo tiempo) y para ello vamos a colocar un bloque Esperar desde el bloque de Tiempo. Si dejamos el tiempo por defecto en 100 milisegundos el diodo se encender\u00e1 y apagar\u00e1 cada segundo (1000 ms = 1s). El programa final queda como vemos en la imagen siguiente y lo tenemos disponible en el enlace Reto-01-LED . Programa final para el LED rojo Conectamos nuestra placa a un puerto USB del ordenador, ponemos en marcha el programa Connector y cargamos el programa en la placa UNO. Podemos observar como el diodo LED rojo parpadea con un intervalo de un segundo. De esta forma el programa queda grabado en la memoria de programa del microcontrolador y el ciclo se repetir\u00e1 por tiempo indefinido o hasta que quitemos la alimentaci\u00f3n a la placa. Si alimentamos la placa externamente con una fuente de alimentaci\u00f3n se ejecutar\u00e1 el programa en memoria. Actividades de ampliaci\u00f3n \u00b6 R1.A1 . Cambiar los tiempos para que el parpadeo sea m\u00e1s r\u00e1pido, mas lento y que los tiempos de encendido y apagado no coincidan. R1.A2 . Repetir el ejercicio A1 utilizando el LED azul conectado al pin D13. Diodo LED azul conectado a D13 Soluci\u00f3n R1.A1 \u00b6 M\u00e1s r\u00e1pido: Programa para parpadeo m\u00e1s r\u00e1pido. Establecemos el tiempo en 500 ms. Programa disponible en el enlace Reto-01-A1:mas-rapido . Parpadeo a 500 ms M\u00e1s lento: Programa para parpadeo m\u00e1s lento. Establecemos el tiempo en 2 segundos. Programa disponible en el enlace Reto-01-A1:mas-lento Parpadeo cada 2 segundos Diferentes tiempos: Tiempos de encendido y apagado diferentes. Establecemos ON = 1500 ms y OFF = 250 ms. Programa disponible en el enlace Reto-01-A1:diferentes Estados ON y OFF con tiempos diferentes Soluci\u00f3n R1.A2 \u00b6 Cambiando el diodo LED de los ejercicios de la actividad A1 ya tenemos la soluci\u00f3n para esta actividad A2. Es un buen ejercicio jugar con los tiempos para ver el efecto real que estos tienen. En las im\u00e1genes siguientes tenemos las soluciones y los enlaces a los programas. M\u00e1s r\u00e1pido Parpadeo azul a 500 ms M\u00e1s lento Parpadeo azul a 2s Diferentes tiempos Parpadeo azul tiempos diferentes","title":"Reto-01. LED"},{"location":"R01/#reto-01-led","text":"","title":"Reto-01. LED"},{"location":"R01/#enunciado","text":"Realizar un programa que encienda y apague el LED rojo conectado al pin D12.","title":"Enunciado"},{"location":"R01/#teoria","text":"El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energia Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico. Aspecto y s\u00edmbolo del LED El color de la c\u00e1psula es simplemente orientativo de la longitud de onda que define realmente el color de la luz emitida. Por ello el LED con la c\u00e1psula transparente puede emitir en cualquiera de los colores del espectro visible. El LED es un dispositivo que tiene polaridad siendo su comportamiento el siguiente: En polarizaci\u00f3n directa (\u00e1nodo a positivo y c\u00e1todo a negativo) el LED emite luz y en polarizaci\u00f3n inversa (\u00e1nodo negativo y c\u00e1todo positivo) se comporta pr\u00e1cticamente como un interruptor abierto. Para su correcto funcionamiento el diodo LED se polariza poni\u00e9ndole en serie una resistencia que limita la corriente que pasa a trav\u00e9s del mismo y, por tanto, determina el nivel de brillo de la luz emitida. Sin entrar en detalles en la tabla siguiente se dan los valores de tensi\u00f3n directa (VF) y corriente directa (IF) para los colores mas habituales de LEDs. A partir de estos valores y el valor de tensi\u00f3n de alimentaci\u00f3n de nuestro LED podemos calcular el valor de la resistencia serie sin mas que aplicar la formula indicada. Tensi\u00f3n y corriente para distintos colores","title":"Teor\u00eda"},{"location":"R01/#en-la-tdr-steam","text":"La placa Imagina TDR STEAM dispone de un LED rojo conectado al pin D12 tal y como se indica en la serigrafia de la propia placa y que podemos ver en la imagen siguiente: LED rojo en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R01/#programando-el-reto","text":"Entramos en ArduinoBlocks y nos identificamos convenientemente. Vamos a crear un nuevo proyecto para la placa TdR STEAM siguiendo el procedimiento que vemos en la siguiente animaci\u00f3n: Escogemos el bloque LED de TDR STEAM y lo colocamos en el bucle, quedando algo similar a la imagen siguiente: Bloque LED de TDR STEAM Podemos comprobar haciendo clic sobre las flechas como podemos cambiar de LED y tambi\u00e9n como podemos cambiar de estado al LED. Si solamente dejamos este bloque el LED permanecer\u00e1 encendido de forma permanente y para que se acabe debemos ponerlo en estado OFF. En la imagen siguiente vemos el programa como quedar\u00eda. LED D12 a ON y OFF Pero este programa no nos permite ver el efecto de encendido y apagado del LED debido a la velocidad de procesamiento que tiene la placa UNO que tipicamente trabaja a 16 MHz. Esto supone que el micro tarda en ejecutar una instrucci\u00f3n algo mas de 0,06 microsegundos que es mucho menor que la persistencia visual humana de 0,1 segundo aproximadamente. Es decir, en realidad el LED se enciende y se apaga, pero nuestro ojo no puede apreciarlo y lo ver\u00e1 siempre encendido debido a la persistencia visual. Tenemos por tanto que dejar el diodo un tiempo encendido y otro apagado (pueden ser el mismo tiempo) y para ello vamos a colocar un bloque Esperar desde el bloque de Tiempo. Si dejamos el tiempo por defecto en 100 milisegundos el diodo se encender\u00e1 y apagar\u00e1 cada segundo (1000 ms = 1s). El programa final queda como vemos en la imagen siguiente y lo tenemos disponible en el enlace Reto-01-LED . Programa final para el LED rojo Conectamos nuestra placa a un puerto USB del ordenador, ponemos en marcha el programa Connector y cargamos el programa en la placa UNO. Podemos observar como el diodo LED rojo parpadea con un intervalo de un segundo. De esta forma el programa queda grabado en la memoria de programa del microcontrolador y el ciclo se repetir\u00e1 por tiempo indefinido o hasta que quitemos la alimentaci\u00f3n a la placa. Si alimentamos la placa externamente con una fuente de alimentaci\u00f3n se ejecutar\u00e1 el programa en memoria.","title":"Programando el reto"},{"location":"R01/#actividades-de-ampliacion","text":"R1.A1 . Cambiar los tiempos para que el parpadeo sea m\u00e1s r\u00e1pido, mas lento y que los tiempos de encendido y apagado no coincidan. R1.A2 . Repetir el ejercicio A1 utilizando el LED azul conectado al pin D13. Diodo LED azul conectado a D13","title":"Actividades de ampliaci\u00f3n"},{"location":"R01/#solucion-r1a1","text":"M\u00e1s r\u00e1pido: Programa para parpadeo m\u00e1s r\u00e1pido. Establecemos el tiempo en 500 ms. Programa disponible en el enlace Reto-01-A1:mas-rapido . Parpadeo a 500 ms M\u00e1s lento: Programa para parpadeo m\u00e1s lento. Establecemos el tiempo en 2 segundos. Programa disponible en el enlace Reto-01-A1:mas-lento Parpadeo cada 2 segundos Diferentes tiempos: Tiempos de encendido y apagado diferentes. Establecemos ON = 1500 ms y OFF = 250 ms. Programa disponible en el enlace Reto-01-A1:diferentes Estados ON y OFF con tiempos diferentes","title":"Soluci\u00f3n R1.A1"},{"location":"R01/#solucion-r1a2","text":"Cambiando el diodo LED de los ejercicios de la actividad A1 ya tenemos la soluci\u00f3n para esta actividad A2. Es un buen ejercicio jugar con los tiempos para ver el efecto real que estos tienen. En las im\u00e1genes siguientes tenemos las soluciones y los enlaces a los programas. M\u00e1s r\u00e1pido Parpadeo azul a 500 ms M\u00e1s lento Parpadeo azul a 2s Diferentes tiempos Parpadeo azul tiempos diferentes","title":"Soluci\u00f3n R1.A2"},{"location":"R02/","text":"Reto-02. LEDs rojo y azul \u00b6 Enunciado \u00b6 Como ya hemos visto anteriormente la placa dispone de dos LED (uno rojo y otro azul). Vamos a realizar un programa para que se vayan alternando en su encendido y apagado. Teor\u00eda \u00b6 Vamos a ver como se hacen los ciclos de repetici\u00f3n o bucles en ArduinoBlocks. En el men\u00fa de Control existe el bloque Repetir (valor) veces hacer\u2026 como el de la imagen siguiente: Bucle Lo que pongamos en hacer se va a repetir tantas veces como indiquemos en el n\u00famero de veces, que por defecto estar\u00e1 a 10. En realidad lo que estamos haciendo es lo que en programaci\u00f3n se conoce como bucle for. En la TdR STEAM \u00b6 Los dos LEDs de la TdR-STEAM Programando el reto \u00b6 Vamos a hacer que ambos diodos se enciendan y apaguen de forma simultanea con un programa como el siguiente, que lo tenemos disponible en Reto-02. LED-rojo-azul Intermitencia LEDs rojo y azul Actividades de ampliaci\u00f3n \u00b6 R2.A1 . (No resuelta) Hacer que los LEDs rojo y azul se enciendan simultaneamente con tiempos de espera de 300ms y 150ms respectivamente. R2.A2 . Realizar 4 intermitencias de 500ms con el LED azul y cuando estas acaben dejar el LED rojo encendido durante 1.5 segundos. Esperar un segundo para iniciar de nuevo el proceso. R3.A3 . Realiza 5 intermitencias de 500ms con el LED azul cada vez que el LED rojo lo hace 3 veces a intervalos de 150ms. Esperar un segundo para iniciar de nuevo el proceso. Soluci\u00f3n R2.A2 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-02-A2 Soluci\u00f3n a la Actividad 2 del Reto 2 Soluci\u00f3n R2.A3 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-02-A3 Soluci\u00f3n a la Actividad 3 del Reto 2","title":"Reto-02. LEDs rojo y azul"},{"location":"R02/#reto-02-leds-rojo-y-azul","text":"","title":"Reto-02. LEDs rojo y azul"},{"location":"R02/#enunciado","text":"Como ya hemos visto anteriormente la placa dispone de dos LED (uno rojo y otro azul). Vamos a realizar un programa para que se vayan alternando en su encendido y apagado.","title":"Enunciado"},{"location":"R02/#teoria","text":"Vamos a ver como se hacen los ciclos de repetici\u00f3n o bucles en ArduinoBlocks. En el men\u00fa de Control existe el bloque Repetir (valor) veces hacer\u2026 como el de la imagen siguiente: Bucle Lo que pongamos en hacer se va a repetir tantas veces como indiquemos en el n\u00famero de veces, que por defecto estar\u00e1 a 10. En realidad lo que estamos haciendo es lo que en programaci\u00f3n se conoce como bucle for.","title":"Teor\u00eda"},{"location":"R02/#en-la-tdr-steam","text":"Los dos LEDs de la TdR-STEAM","title":"En la TdR STEAM"},{"location":"R02/#programando-el-reto","text":"Vamos a hacer que ambos diodos se enciendan y apaguen de forma simultanea con un programa como el siguiente, que lo tenemos disponible en Reto-02. LED-rojo-azul Intermitencia LEDs rojo y azul","title":"Programando el reto"},{"location":"R02/#actividades-de-ampliacion","text":"R2.A1 . (No resuelta) Hacer que los LEDs rojo y azul se enciendan simultaneamente con tiempos de espera de 300ms y 150ms respectivamente. R2.A2 . Realizar 4 intermitencias de 500ms con el LED azul y cuando estas acaben dejar el LED rojo encendido durante 1.5 segundos. Esperar un segundo para iniciar de nuevo el proceso. R3.A3 . Realiza 5 intermitencias de 500ms con el LED azul cada vez que el LED rojo lo hace 3 veces a intervalos de 150ms. Esperar un segundo para iniciar de nuevo el proceso.","title":"Actividades de ampliaci\u00f3n"},{"location":"R02/#solucion-r2a2","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-02-A2 Soluci\u00f3n a la Actividad 2 del Reto 2","title":"Soluci\u00f3n R2.A2"},{"location":"R02/#solucion-r2a3","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-02-A3 Soluci\u00f3n a la Actividad 3 del Reto 2","title":"Soluci\u00f3n R2.A3"},{"location":"R03/","text":"Reto-03. LED RGB \u00b6 Enunciado \u00b6 El reto b\u00e1sico consistir\u00e1 en ver los colores primarios y su mezcla mediante el uso del LED RGB y tambi\u00e9n habr\u00e1 un reto secundario sobre el control de intensidad mediante PWM. Teor\u00eda \u00b6 LED RGB \u00b6 Un LED RGB es en realidad un encapsulado que incorpora tres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En el caso de la TDR-STEAM se utiliza un LED RGB con los tres LEDs unidos por su c\u00e1todo o terminal negativo, es decir es un LED RGB de c\u00e1todo com\u00fan. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. RGB El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB. PWM \u00b6 PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emula una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. Aunque las placas tipo UNO disponen de seis salidas PWM (D3, D5, D6, D9, D10 y D11) en la placa TdR STEAM solamente se controlan por PWM los pines D6, D9 y D10 que es donde va conectado el LED RGB. En la TdR STEAM \u00b6 En la placa existe un LED RGB 5050 de 6 pines como el de la imagen siguiente conectado a los pines D6 (Red), D9 (Green) y D10(Blue). Estos tres pines son PWM y nos van a permitir regular su intensidad. RGB 5050 En la placa TdR STEAM se localiza donde vemos en la imagen siguiente: LED RGB Programando el reto \u00b6 En ArduinoBlocks disponemos de los dos bloques que vemos en la imagen siguiente para el control PWM del LED RGB. Bloques ArduinoBlocks para control PWM del LED RGB El bloque superior permite asignar el color a partir de la paleta que se despliega al hacer clic sobre el cuadrado de color y en el inferior debemos introducir el valor num\u00e9rico (entre 0 y 255) correspondiente a cada color primario en cada uno de los tres colores RGB. Con estos bloques no tenemos que preocuparnos por saber las conexiones de cada diodo ya que est\u00e1n asignadas internamente en el bloque. Tambi\u00e9n hemos visto que el LED RGB tiene asociados tres pines y por tanto podemos tratar a cada LED de forma individual. Pero para poder hacerlo debemos crear un tipo de proyecto \"Arduino UNO\" y no como hasta ahora \"Arduino UNO + Imagina TdR STEAM\". Esto nos va a permitir disponer del bloque LED que est\u00e1 dentro de \"Actuadores\" con todos los pines digitales configurables. De esta forma un programa como el de la imagen siguiente nos va a permitir activar de forma individual cada diodo LED. La soluci\u00f3n al reto la tenemos disponible en Reto-03 . Reto 03 Actividades de ampliaci\u00f3n \u00b6 R3.A1 . A partir de la idea del reto realizar un programa que muestre sucesivamente los siguientes colores: magenta o violeta, cian o azul claro, amarillo y blanco. Ay\u00fadate del gr\u00e1fico que muestra el modelo aditivo de colores que hemos puesto al principio de la teor\u00eda. R3.A2 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"Arduino UNO + Imagina TdR STEAM\" y el bloque con la paleta de colores. R3.A3 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"Arduino UNO + Imagina TdR STEAM\" y el bloque con el valor num\u00e9rico de cada color. R3.A4 . Realizar un programa que muestre de manera secuencial los colores del arcoiris en el orden que vemos en la imagen siguiente. Colores del arcoiris Soluci\u00f3n R3.A1 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A1 . Modelo aditivo de colores primarios Soluci\u00f3n R3.A2 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A2 . Actividad 2 del reto 3 Soluci\u00f3n R3.A3 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A3 . Actividad 3 del reto 3 Soluci\u00f3n R3.A4 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A4 . Actividad 4 del reto 3","title":"Reto-03. LED RGB"},{"location":"R03/#reto-03-led-rgb","text":"","title":"Reto-03. LED RGB"},{"location":"R03/#enunciado","text":"El reto b\u00e1sico consistir\u00e1 en ver los colores primarios y su mezcla mediante el uso del LED RGB y tambi\u00e9n habr\u00e1 un reto secundario sobre el control de intensidad mediante PWM.","title":"Enunciado"},{"location":"R03/#teoria","text":"","title":"Teor\u00eda"},{"location":"R03/#led-rgb","text":"Un LED RGB es en realidad un encapsulado que incorpora tres diodos LED, uno por cada color fundamental. Los colores primarios en \u00f3ptica son el rojo, el verde y el azul y la correcta combinaci\u00f3n, en t\u00e9rminos de intensidad, de ellos originar\u00e1 cualquiera de los colores secundarios. Las siglas RGB son el acr\u00f3nimo de Red, Green y Blue. En el caso de la TDR-STEAM se utiliza un LED RGB con los tres LEDs unidos por su c\u00e1todo o terminal negativo, es decir es un LED RGB de c\u00e1todo com\u00fan. En la imagen siguiente vemos el modelo aditivo de los colores rojo, verde y azul. RGB El s\u00edmbolo y la representaci\u00f3n mas comunes de este componente lo vemos en la imagen siguiente: S\u00edmbolo y representaci\u00f3n Te\u00f3ricamente en Arduino, cada uno de esos LEDs podr\u00eda adoptar 256 (valores entre 0 y 255) colores diferentes, es decir, un total de 16.777.216 posibles colores diferentes con un LED RGB.","title":"LED RGB"},{"location":"R03/#pwm","text":"PWM son siglas en ingl\u00e9s que significan Pulse Width Modulation y que lo podemos traducir a espa\u00f1ol como Modulaci\u00f3n de ancho de pulso. Los pines PWM permiten generar una se\u00f1al anal\u00f3gica mediante una salida digital mapeada con 8 bits, o lo que es lo mismo, valores del 0 al 255, es decir mediante una salida PWM podemos emular una se\u00f1al anal\u00f3gica. En realidad una placa tipo UNO no es capaz de generar una salida anal\u00f3gica y lo que se hace es emplear un truco que consiste en activar una salida digital durante un tiempo y el resto del tiempo del ciclo mantenerla desactivada. El valor promedio de la salida es el valor anal\u00f3gico. En el tipo de modulaci\u00f3n PWM mantendremos constante la frecuencia, o lo que es lo mismo, el tiempo entre pulsos y lo que se hace es variar la anchura del pulso. La proporci\u00f3n de tiempo que est\u00e1 encendida la se\u00f1al, respecto al total del ciclo, se denomina ciclo de trabajo o Duty cycle, y generalmente se expresa en tanto por ciento. En la imagen siguiente vemos se\u00f1ales con distintos ciclos de trabajo. Distintos Duty cicle Es importante recordar que en una salida PWM el valor de la tensi\u00f3n es 5V por lo que si alimentamos un dispositivo de 3V a partir de una salida de 5V lo da\u00f1aremos de forma irreversible. Las se\u00f1ales PWM emula una se\u00f1al anal\u00f3gica para aplicaciones como variar la luminosidad de un LED y variar la velocidad de motores de corriente continua. Aunque las placas tipo UNO disponen de seis salidas PWM (D3, D5, D6, D9, D10 y D11) en la placa TdR STEAM solamente se controlan por PWM los pines D6, D9 y D10 que es donde va conectado el LED RGB.","title":"PWM"},{"location":"R03/#en-la-tdr-steam","text":"En la placa existe un LED RGB 5050 de 6 pines como el de la imagen siguiente conectado a los pines D6 (Red), D9 (Green) y D10(Blue). Estos tres pines son PWM y nos van a permitir regular su intensidad. RGB 5050 En la placa TdR STEAM se localiza donde vemos en la imagen siguiente: LED RGB","title":"En la TdR STEAM"},{"location":"R03/#programando-el-reto","text":"En ArduinoBlocks disponemos de los dos bloques que vemos en la imagen siguiente para el control PWM del LED RGB. Bloques ArduinoBlocks para control PWM del LED RGB El bloque superior permite asignar el color a partir de la paleta que se despliega al hacer clic sobre el cuadrado de color y en el inferior debemos introducir el valor num\u00e9rico (entre 0 y 255) correspondiente a cada color primario en cada uno de los tres colores RGB. Con estos bloques no tenemos que preocuparnos por saber las conexiones de cada diodo ya que est\u00e1n asignadas internamente en el bloque. Tambi\u00e9n hemos visto que el LED RGB tiene asociados tres pines y por tanto podemos tratar a cada LED de forma individual. Pero para poder hacerlo debemos crear un tipo de proyecto \"Arduino UNO\" y no como hasta ahora \"Arduino UNO + Imagina TdR STEAM\". Esto nos va a permitir disponer del bloque LED que est\u00e1 dentro de \"Actuadores\" con todos los pines digitales configurables. De esta forma un programa como el de la imagen siguiente nos va a permitir activar de forma individual cada diodo LED. La soluci\u00f3n al reto la tenemos disponible en Reto-03 . Reto 03","title":"Programando el reto"},{"location":"R03/#actividades-de-ampliacion","text":"R3.A1 . A partir de la idea del reto realizar un programa que muestre sucesivamente los siguientes colores: magenta o violeta, cian o azul claro, amarillo y blanco. Ay\u00fadate del gr\u00e1fico que muestra el modelo aditivo de colores que hemos puesto al principio de la teor\u00eda. R3.A2 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"Arduino UNO + Imagina TdR STEAM\" y el bloque con la paleta de colores. R3.A3 . Realizar un programa que nos muestre los tres colores primarios a partir de un proyecto tipo \"Arduino UNO + Imagina TdR STEAM\" y el bloque con el valor num\u00e9rico de cada color. R3.A4 . Realizar un programa que muestre de manera secuencial los colores del arcoiris en el orden que vemos en la imagen siguiente. Colores del arcoiris","title":"Actividades de ampliaci\u00f3n"},{"location":"R03/#solucion-r3a1","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A1 . Modelo aditivo de colores primarios","title":"Soluci\u00f3n R3.A1"},{"location":"R03/#solucion-r3a2","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A2 . Actividad 2 del reto 3","title":"Soluci\u00f3n R3.A2"},{"location":"R03/#solucion-r3a3","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A3 . Actividad 3 del reto 3","title":"Soluci\u00f3n R3.A3"},{"location":"R03/#solucion-r3a4","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-03-A4 . Actividad 4 del reto 3","title":"Soluci\u00f3n R3.A4"},{"location":"R04/","text":"Reto-04. Zumbador \u00b6 Enunciado \u00b6 Trabajaremos con el buzzer o zumbador partiendo de la reproducci\u00f3n de sonidos b\u00e1sicos hasta llegar a la reproducci\u00f3n de melod\u00edas completas. Teor\u00eda \u00b6 El buzzer o zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de dos tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido. El zumbador que incorpora la placa TdR STEAM es de tipo pasivo y est\u00e1 conectado al pin D8. Una de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas En ArduinoBlocks disponemos de un bloque que nos permite reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: Bloque Reproducir RTTTL Este bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melodia es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente. En la TdR STEAM \u00b6 El buzzer en la TdR STEAM Programando el reto \u00b6 Los cuatro bloques destinados a trabajar con el zumbador los vemos en la imagen siguiente: Los 4 bloques para trabajar con el zumbador En el bloque Zumbador podemos modificar dos par\u00e1metros, el tiempo que dura cada sonido expresado en milisegundos (campo Ms) y la frecuencia en Hz a la que reproducir\u00e1 el sonido el zumbador (campo Hz). Vamos a comenzar haciendo un programa que reproduzca tres de las notas de la escala musical vista anteriormente. La soluci\u00f3n al reto la tenemos disponible en Reto-04 . Reto 04 Actividades de ampliaci\u00f3n \u00b6 R4.A1 . Reproducir la escala musical con las notas b\u00e1sicas utilizando los bloques Zumbador y Tono R4.A2 . Reproducir la melod\u00eda de la imagen siguiente sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito 750ms y las blancas 1000ms. Himno a la alegria R4.A3 . Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada). R4.A4 . (No solucionado) Reproducir alguna otra melod\u00eda que descarguemos de las p\u00e1ginas web propuestas. Soluci\u00f3n R4.A1 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-04-A1: escala-musical . Actividad 1 del reto 4 Soluci\u00f3n R4.A2 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-04-A2: partitura . Actividad 2 del reto 4 Mas adelante se explicar\u00e1 la forma de construcci\u00f3n del programa utilizando funciones. La melod\u00eda es el himno a la alegra. Soluci\u00f3n R4.A3 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-04-A3: melodias-RTTTL . La soluci\u00f3n es sencilla, basta con escogger el bloque Zumbador Reproducir RTTTL y acoplarle el bloque RTTTL escogiendo la melod\u00eda a reproducir. En la soluci\u00f3n se han puestos dos grupos de bloques con dos de las posibles melod\u00edas dejando un tiempo de 5 segundos entre una y otra. En este caso adem\u00e1s los bloques se han colocado en \"Inicializar\" por lo que solamente se van a ejecutar una vez y no de manera indefinida. Actividad 3 del reto 4","title":"Reto-04. Zumbador"},{"location":"R04/#reto-04-zumbador","text":"","title":"Reto-04. Zumbador"},{"location":"R04/#enunciado","text":"Trabajaremos con el buzzer o zumbador partiendo de la reproducci\u00f3n de sonidos b\u00e1sicos hasta llegar a la reproducci\u00f3n de melod\u00edas completas.","title":"Enunciado"},{"location":"R04/#teoria","text":"El buzzer o zumbador o altavoz es un transductor electroac\u00fastico (convierte una se\u00f1al el\u00e9ctrica en una onda de sonido) que produce un determinado zumbido o sonido. Existen de dos tipos: Pasivos : no disponen de electr\u00f3nica interna, por lo que tenemos que proporcionar una se\u00f1al el\u00e9ctrica para conseguir el sonido deseado. Activos : disponen de un oscilador interno, por lo que \u00fanicamente tenemos que alimentar el dispositivo para que se produzca el sonido. El zumbador que incorpora la placa TdR STEAM es de tipo pasivo y est\u00e1 conectado al pin D8. Una de los par\u00e1metros que caracterizan a un sonido es su frecuencia de emisi\u00f3n, siendo la frecuencia el n\u00famero de veces que se repite por unidad de tiempo (segundo). La transmisi\u00f3n del sonido se realiza por ondas a trav\u00e9s en cualquier medio (s\u00f3lido, l\u00edquido o gaseoso) excepto en el vac\u00edo. La frecuencia de un sonido nos indica cuantos ciclos por segundo tiene una onda. En la imagen y la tabla siguientes vemos un dibujo con un fragmento de las teclas de un piano estando todo referido a una nota est\u00e1ndar, la nota \"La\" central que tiene una frecuencia de 440 Hz. Podemos ver la nota musical que reproduce, en las dos notaciones m\u00e1s comunes de los sonidos (Ingl\u00e9s: C D E F G A B, Alem\u00e1n: C D E F G A H, Espa\u00f1ol, italiano y franc\u00e9s: Do Re Mi Fa Sol La Si) y adem\u00e1s se encuentra la frecuencia que produce esa nota musical. Secci\u00f3n de piano y notas En ArduinoBlocks disponemos de un bloque que nos permite reproducir cualquier melod\u00eda RTTTL (del ingl\u00e9s, Ring Tone Text Transfer Language) y es el que vemos en la imagen siguiente: Bloque Reproducir RTTTL Este bloque permite reproducir una melod\u00eda a partir de un texto con formato RTTTL, formato desarrollado por Nokia para ser usado para transferir tonos de llamada a tel\u00e9fonos m\u00f3viles. El formato RTTTL es una cadena dividida en tres secciones: nombre, valor predeterminado y datos. Por ejemplo, la siguiente cadena de texto se corresponde con la Intro de Donkey Kong: d=4,o=5,b=140:8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6,8a#,8p,8d6,16p,16f.6,16g.6,16f.6 Lo \u00fanico que tenemos que hacer para reproducir la melodia es pegar esta cadena en la zona de texto del bloque. ArduinoBlocks nos suministra informaci\u00f3n y enlaces referentes al tema accediendo desde nuestro proyecto a herramientas y escogiendo RTTTL Info, tal y como vemos en la imagen siguiente: Acceso a RTTTL Info En la imagen siguiente tenemos desplegada la informaci\u00f3n que nos ofrece esta herramienta. Informaci\u00f3n RTTTL Tambi\u00e9n podemos acceder a esta informaci\u00f3n haciendo clic derecho sobre el bloque y escogiendo la opci\u00f3n \"Ayuda\" de entre las mostradas en la ventana emergente.","title":"Teor\u00eda"},{"location":"R04/#en-la-tdr-steam","text":"El buzzer en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R04/#programando-el-reto","text":"Los cuatro bloques destinados a trabajar con el zumbador los vemos en la imagen siguiente: Los 4 bloques para trabajar con el zumbador En el bloque Zumbador podemos modificar dos par\u00e1metros, el tiempo que dura cada sonido expresado en milisegundos (campo Ms) y la frecuencia en Hz a la que reproducir\u00e1 el sonido el zumbador (campo Hz). Vamos a comenzar haciendo un programa que reproduzca tres de las notas de la escala musical vista anteriormente. La soluci\u00f3n al reto la tenemos disponible en Reto-04 . Reto 04","title":"Programando el reto"},{"location":"R04/#actividades-de-ampliacion","text":"R4.A1 . Reproducir la escala musical con las notas b\u00e1sicas utilizando los bloques Zumbador y Tono R4.A2 . Reproducir la melod\u00eda de la imagen siguiente sabiendo que las negras tienen una duraci\u00f3n de 500ms, las negras con un puntito 750ms y las blancas 1000ms. Himno a la alegria R4.A3 . Reproducir diferentes melod\u00edas a partir de los bloques RTTTL (Ring Tone Text Transfer Language o lenguaje de tonos de llamada). R4.A4 . (No solucionado) Reproducir alguna otra melod\u00eda que descarguemos de las p\u00e1ginas web propuestas.","title":"Actividades de ampliaci\u00f3n"},{"location":"R04/#solucion-r4a1","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-04-A1: escala-musical . Actividad 1 del reto 4","title":"Soluci\u00f3n R4.A1"},{"location":"R04/#solucion-r4a2","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-04-A2: partitura . Actividad 2 del reto 4 Mas adelante se explicar\u00e1 la forma de construcci\u00f3n del programa utilizando funciones. La melod\u00eda es el himno a la alegra.","title":"Soluci\u00f3n R4.A2"},{"location":"R04/#solucion-r4a3","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-04-A3: melodias-RTTTL . La soluci\u00f3n es sencilla, basta con escogger el bloque Zumbador Reproducir RTTTL y acoplarle el bloque RTTTL escogiendo la melod\u00eda a reproducir. En la soluci\u00f3n se han puestos dos grupos de bloques con dos de las posibles melod\u00edas dejando un tiempo de 5 segundos entre una y otra. En este caso adem\u00e1s los bloques se han colocado en \"Inicializar\" por lo que solamente se van a ejecutar una vez y no de manera indefinida. Actividad 3 del reto 4","title":"Soluci\u00f3n R4.A3"},{"location":"R05/","text":"Reto-05. Pulsadores \u00b6 Enunciado \u00b6 Utilizaremos uno, o ambos pulsadores, para llevar a cabo determinadas tareas como respuesta al accionamiento de los mismos. Teor\u00eda \u00b6 En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa UNO. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador En el caso de la TdR STEAM los pulsadores se han configurado para que en reposo pongan a cero su entrada digital correspondiente y que se ponga a uno cuando son accionados. Concepto de variable y de contador \u00b6 El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ... En la TdR STEAM \u00b6 La placa TdR STEAM dispone de dos pulsadores denominados SW1 y SW2 y conectados a los pines digitales D2 y D7 respectivamente. Pulsadores en la TdR STEAM Programando el reto \u00b6 La aplicaci\u00f3n de un pulsador para hacer algo requiere saber si este esta pulsado o no lo est\u00e1 y para ello vamos a necesitar de las sentencias condicionales que podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloque l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. Vamos a hacer un programa en el que preguntemos si el pulsador SW1 (D2) est\u00e1 o no pulsado y si lo est\u00e1 que se encienda el LED rojo (D12) y si no lo pulsamos que permanezca apagado. La soluci\u00f3n al reto la tenemos disponible en Reto-05 y una segunda versi\u00f3n en Reto-05-v2 . Ampliaci\u00f3n sobre programaci\u00f3n del reto \u00b6 Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\". Vamos a hace un programa similar al Reto-05 para hacer que si pulsamos SW2 se encienda el LED azul y si no est\u00e1 pulsado permanecer\u00e1 apagado. La soluci\u00f3n al reto la tenemos disponible en Reto-05-ampliaci\u00f3n-1 . Reto-05-ampliacion-1 El siguiente programa har\u00e1 que se encienda el LED azul al pulsar SW1 y el LED rojo al pulsar SW2 se encienda el rojo permaneciendo apagados si no est\u00e1n pulsados. Observese la primera condici\u00f3n AND (Y) que impide que si pulsamos ambos pulsadores al mismo tiempo se enciendan los LEDs. La soluci\u00f3n al reto la tenemos disponible en Reto-05-ampliaci\u00f3n-2 . Ampliaci\u00f3n 2 del reto 5 Actividades de ampliaci\u00f3n \u00b6 R5.A1 . Resolver el reto inicial de forma que el funcionamiento sea al contrario, es decir, que el LED rojo est\u00e9 siempre encendido y al pulsar SW1 se apague. R5.A2 . Hacer un programa que al pulsar SW1 se encienda el LED azul y que al pulsar SW2 se apague. Como ampliaci\u00f3n se sugiere modificar el programa para que encienda y apague los dos LEDs a un tiempo. R5.A3 . Hacer un programa que emita, usando SW1 como si fuese un tel\u00e9grafo, el c\u00f3digo Morse universal de solicitud de socorro, SOS. R5.A4 . Hacer un programa que al pulsar SW1 encienda el LED azul y que este permanezca encendido hasta que no pulsemos SW1 dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1. Soluci\u00f3n R5.A1 \u00b6 La soluci\u00f3n est\u00e1 en utilizar el operador NOT. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A1 . Actividad 1 del reto 5 Soluci\u00f3n R5.A2 \u00b6 La soluci\u00f3n en esta ocasi\u00f3n est\u00e1 en utilizar el operador NOT y el operador AND. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A2 . Actividad 2 del reto 5 Soluci\u00f3n R5.A3 \u00b6 El alfabeto Morse lo vemos en la imagen siguiente, donde podemos observar que la S son tres puntos o pulsaciones cortas y la O son tres rayas o pulsaciones largas. Sin entrar en mas detalles daremos la soluci\u00f3n considerando SOS como una palabra (es lo universalmente adoptado) de forma que no haremos pausas entre letras. Alfabeto Morse El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A3: Morse . Actividad 3 del reto 5 Soluci\u00f3n R5.A4 \u00b6 Definimos una variable y la utilizamos para resolver el programa mediante un contador. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A4 . Actividad 4 del reto 5","title":"Reto-05. Pulsadores"},{"location":"R05/#reto-05-pulsadores","text":"","title":"Reto-05. Pulsadores"},{"location":"R05/#enunciado","text":"Utilizaremos uno, o ambos pulsadores, para llevar a cabo determinadas tareas como respuesta al accionamiento de los mismos.","title":"Enunciado"},{"location":"R05/#teoria","text":"En la tabla siguiente vemos la simbolog\u00eda y algunos ejemplos del aspecto f\u00edsico de estos elementos. S\u00edmbolos y aspecto real de un pulsador Se trata de un dispositivo que es capaz de abrir o cerrar el paso de la corriente el\u00e9ctrica mientras permanece accionado, es decir, su funci\u00f3n no queda anclada como por ejemplo en los interruptores de la luz de casa, en donde el accionamiento permanece hasta que no se vuelve a accionar. En un pulsador, por contra, su activaci\u00f3n dura mientras lo mantenemos pulsado y vuelve a su estado de reposo en cuanto dejemos de pulsarlo. Mediante la configuraci\u00f3n adecuada podemos convertir un pulsador en un elemento de entrada a alg\u00fan pin de nuestra placa UNO. Las configuraciones m\u00e1s b\u00e1sicas posibles con pulsadores las podemos ver en la imagen siguiente. Configuraci\u00f3n circuito elemental con pulsador En el caso de la TdR STEAM los pulsadores se han configurado para que en reposo pongan a cero su entrada digital correspondiente y que se ponga a uno cuando son accionados.","title":"Teor\u00eda"},{"location":"R05/#concepto-de-variable-y-de-contador","text":"El concepto de variable en programaci\u00f3n consiste simplemente en asignarle un nombre significativo a un espacio de memoria donde almacenar determinada informaci\u00f3n durante la ejecuci\u00f3n normal del programa. El concepto es muy amplio y complejo y en nuestro caso no vamos a entrar en detalles sobre el mismo, pero si indicar que no se debe confundir con el concepto de variable matem\u00e1tica, ya que una expresi\u00f3n como x = x + 1 que es una aberraci\u00f3n en matem\u00e1ticas tiene todo el sentido en programaci\u00f3n. L\u00f3gicamente en matem\u00e1ticas no se puede cumplir pero en programaci\u00f3n significa que a la variable x se le sume uno y el resultado se vuelva a guardar en la misma variable. En ArduinoBlocks podemos crear tres tipos de variables, num\u00e9ricas, de texto o booleanas. En la animaci\u00f3n siguiente podemos ver como se pueden crear, eliminar y renombrar variables. En programaci\u00f3n, llamamos contador a una variable cuyo valor se incrementa o decrementa en un valor fijo para cada iteraci\u00f3n del bucle para el que se ha definido. El uso habitual de un contador es simplemente contar el n\u00famero de veces que itera un bucle en general o de forma mas extensa contar, solamente, aquellas iteraciones en las que se cumpla una determinada condici\u00f3n. Por ejemplo, supongamos que tenemos una variable de nombre Estado de valor inicial cero y que se incremente cada vez que accionamos un pulsador, de esta forma si en un bucle vamos incrementando la variable de uno en uno, tenemos: Estado = 0 // valor inicial Estado = 1 // Estado = Estado + 1 Estado = 2 // Estado = Estado + 1 ...","title":"Concepto de variable y de contador"},{"location":"R05/#en-la-tdr-steam","text":"La placa TdR STEAM dispone de dos pulsadores denominados SW1 y SW2 y conectados a los pines digitales D2 y D7 respectivamente. Pulsadores en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R05/#programando-el-reto","text":"La aplicaci\u00f3n de un pulsador para hacer algo requiere saber si este esta pulsado o no lo est\u00e1 y para ello vamos a necesitar de las sentencias condicionales que podemos encontrar en el bloque l\u00f3gica. Este bloque contiene los elementos que vemos en la imagen siguiente: Bloque l\u00f3gica El funcionamiento es el siguiente: se eval\u00faa la condici\u00f3n que ponemos en \"si\" y si el resultado es verdadero, o sea condici\u00f3n cierta, se realizan las acciones que pongamos en \"hacer\" y si no es cierta dichas acciones no se realizan. En el apartado condici\u00f3n se pueden poner infinidad de factores como pueden ser el estado de sensores, realizar comparaciones, hacer operaciones matem\u00e1ticas, etc. Vamos a hacer un programa en el que preguntemos si el pulsador SW1 (D2) est\u00e1 o no pulsado y si lo est\u00e1 que se encienda el LED rojo (D12) y si no lo pulsamos que permanezca apagado. La soluci\u00f3n al reto la tenemos disponible en Reto-05 y una segunda versi\u00f3n en Reto-05-v2 .","title":"Programando el reto"},{"location":"R05/#ampliacion-sobre-programacion-del-reto","text":"Si hemos sido observadores hemos visto en los bloques \"si\" de \"L\u00f3gica\" un signo mas (+) en la parte superior izquierda tanto del condicional \"if\" como la del \"if ... else\" tal y como se destaca en la imagen siguiente. A\u00f1adir opciones else if Cada vez que pulsemos sobre el signo mas se a\u00f1adir\u00e1 una cl\u00e1usula \"else if\" a la principal y podemos a\u00f1adir tantas como necesitemos. Esta cl\u00e1usula nos va a permitir establecer una nueva condici\u00f3n.En la imagen siguiente vemos a\u00f1adidas dos para el caso de \"if ... else\". En la imagen observamos el c\u00f3digo equivalente y las distintas condiciones que se pueden establecer. Clausula if...else con dos else if El signo menos (-) que aparece en la imagen sirve para eliminar la correspondiente cl\u00e1usula \"else if\". Vamos a hace un programa similar al Reto-05 para hacer que si pulsamos SW2 se encienda el LED azul y si no est\u00e1 pulsado permanecer\u00e1 apagado. La soluci\u00f3n al reto la tenemos disponible en Reto-05-ampliaci\u00f3n-1 . Reto-05-ampliacion-1 El siguiente programa har\u00e1 que se encienda el LED azul al pulsar SW1 y el LED rojo al pulsar SW2 se encienda el rojo permaneciendo apagados si no est\u00e1n pulsados. Observese la primera condici\u00f3n AND (Y) que impide que si pulsamos ambos pulsadores al mismo tiempo se enciendan los LEDs. La soluci\u00f3n al reto la tenemos disponible en Reto-05-ampliaci\u00f3n-2 . Ampliaci\u00f3n 2 del reto 5","title":"Ampliaci\u00f3n sobre programaci\u00f3n del reto"},{"location":"R05/#actividades-de-ampliacion","text":"R5.A1 . Resolver el reto inicial de forma que el funcionamiento sea al contrario, es decir, que el LED rojo est\u00e9 siempre encendido y al pulsar SW1 se apague. R5.A2 . Hacer un programa que al pulsar SW1 se encienda el LED azul y que al pulsar SW2 se apague. Como ampliaci\u00f3n se sugiere modificar el programa para que encienda y apague los dos LEDs a un tiempo. R5.A3 . Hacer un programa que emita, usando SW1 como si fuese un tel\u00e9grafo, el c\u00f3digo Morse universal de solicitud de socorro, SOS. R5.A4 . Hacer un programa que al pulsar SW1 encienda el LED azul y que este permanezca encendido hasta que no pulsemos SW1 dos veces mas (3 pulsaciones en total), en cuyo caso se apagar\u00e1.","title":"Actividades de ampliaci\u00f3n"},{"location":"R05/#solucion-r5a1","text":"La soluci\u00f3n est\u00e1 en utilizar el operador NOT. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A1 . Actividad 1 del reto 5","title":"Soluci\u00f3n R5.A1"},{"location":"R05/#solucion-r5a2","text":"La soluci\u00f3n en esta ocasi\u00f3n est\u00e1 en utilizar el operador NOT y el operador AND. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A2 . Actividad 2 del reto 5","title":"Soluci\u00f3n R5.A2"},{"location":"R05/#solucion-r5a3","text":"El alfabeto Morse lo vemos en la imagen siguiente, donde podemos observar que la S son tres puntos o pulsaciones cortas y la O son tres rayas o pulsaciones largas. Sin entrar en mas detalles daremos la soluci\u00f3n considerando SOS como una palabra (es lo universalmente adoptado) de forma que no haremos pausas entre letras. Alfabeto Morse El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A3: Morse . Actividad 3 del reto 5","title":"Soluci\u00f3n R5.A3"},{"location":"R05/#solucion-r5a4","text":"Definimos una variable y la utilizamos para resolver el programa mediante un contador. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-05-A4 . Actividad 4 del reto 5","title":"Soluci\u00f3n R5.A4"},{"location":"R06/","text":"Reto-06. Potenci\u00f3metro \u00b6 Enunciado \u00b6 Introducir el uso de las entradas anal\u00f3gicas para visualizar los cambios que hagamos con el potenciometro en el terminal serie o consola serie. Cuando hablamos de lecturas anal\u00f3gicas suele ser muy \u00fatil el uso del mapeo, concepto que tambi\u00e9n vamos a introducir y que veremos en la segunda parte del reto. Teor\u00eda \u00b6 Antes de nada ya hemos indicado que el potenciometro va conectado a un pin anal\u00f3gico y es en este momento cuando vamos a establecer la diferencia entre los conceptos de anal\u00f3gico y de digital. Una clasificaci\u00f3n de los circuitos electr\u00f3nicos es dividirlos en dos grandes categor\u00edas: digitales y anal\u00f3gicos. La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como 0 - 1, alto - bajo, on - off, etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. La electr\u00f3nica anal\u00f3gica emplea magnitudes con valores continuos. En concreto en las placas basadas en Arduino UNO, las entradas anal\u00f3gicas pueden tener 210 valores (10 bits de resoluci\u00f3n), es decir, valores comprendidos entre 0 y 1023. Estos valores se pueden expresar de forma num\u00e9rica o de forma porcentual, correspondiendo el 0 a un 0% y el 1023 al 100%. El potenci\u00f3metro \u00b6 En la imagen siguiente vemos el aspecto de un modelo concreto de potenciometro as\u00ed como los s\u00edmbolos habituales del mismo. La numeraci\u00f3n indica lo siguiente: Terminales 1 y 3 son los contactos unidos a los extremos de la resistencia fija o resistencia total del potenciometro. Terminal 2 es el contacto que va unido al cursor o parte m\u00f3vil que se desliza sobre la resistencia fija haciendo que la resistencia entre un terminal y el cursor var\u00ede en funci\u00f3n de la posici\u00f3n de este. Aspecto y s\u00edmbolo del potenci\u00f3metro La posici\u00f3n del cursor se determina de forma mec\u00e1nica y son adecuados para usarlos como elementos de control de tensi\u00f3n (conexi\u00f3n en serie) o de corriente (conexi\u00f3n en paralelo). Los potenciometros del tipo que estamos viendo (existen de otros muchos tipos) tienen un funcionamiento en forma de rotaci\u00f3n con un \u00e1ngulo de unos 270 grados entre los puntos mas extremos. El terminal o consola serie \u00b6 Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en AB A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa UNO y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad es de 9600 baudios o bits por segundo y otras velocidades comunmente utilizadas son: 4800, 19200, 38400, 57600, 115200. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n. Serial Plotter - Datalogger \u00b6 Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger Mapeo \u00b6 Hemos indicado que las entradas anal\u00f3gicas trabajan con 10 bits, o sea valores comprendidos entre 0 y 1023 (210) y tambi\u00e9n que la salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255 (28), por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa Matem\u00e1ticas con el aspecto de la imagen siguiente: Bloque mapear Este bloque permite modificar un valor o variable desde un rango origen a un rango destino. Esta funci\u00f3n es especialmente \u00fatil para adaptar los valores le\u00eddos de sensores o para adaptar valores a aplicar en un actuador. En la TdR STEAM \u00b6 El potenciometro de la TdR STEAM Programando el reto \u00b6 Parte 1 . Vamos a guardar los datos le\u00eddos del potenci\u00f3metro en una variable y mostrarlos a trav\u00e9s de la consola serie. La soluci\u00f3n al reto la tenemos disponible en Reto-06: Parte 1 que es el programa que vemos en la imagen siguiente: Parte 1 del reto 6 Si cargamos el programa en nuestra placa y posteriormente activamos la consola y conectamos ArduinoBlocks con nuestro ordenador podemos ver un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenciometro. Aspecto de la consola Para entender el significado del check \"salto de linea\" del bloque \"Enviar\" podemos desactivarlo y volver a hacer el mismo proceso. Parte 2 . Vamos a modificar el programa de la parte 1 del reto para mapear los datos antes de enviarlos a la consola serie. La soluci\u00f3n al reto la tenemos disponible en Reto-06: Parte 2 que es el programa que vemos en la imagen siguiente: Parte 2 del reto 6 El resultado ahora lo vemos en la imagen siguiente: Aspecto de la consola Ampliaci\u00f3n . Vamos ahora a mapear y mostrar los datos le\u00eddos del potenci\u00f3metro en el Serial Plotter. La soluci\u00f3n al reto la tenemos disponible en Reto-06: Ampliacion que es el programa que vemos en la imagen siguiente: Ampliaci\u00f3n del reto 6, serial plotter Si activamos el Serial Plotter y vamos variando el potenciometro veremos el resultado en el mismo, obteniendo algo similar a la imagen siguiente: Aspecto del Serial Plotter Actividades de ampliaci\u00f3n \u00b6 R6.A1 . Utilizaci\u00f3n del bloque \"crear texto con ...\" del men\u00fa \"Texto\". Utilizaremos cualquiera de los programas vistos en el reto y configuraremos el nuevo bloque para que en cada l\u00ednea nos muestre el mensaje \"El valor del potenciometro es: \", a continuaci\u00f3n nos muestre el valor y tras el mismo el s\u00edmbolo % porque configuraremos la lectura en porcentaje. Dejaremos transcurrir un tiempo de 3s entre cada muestra de salida por consola. R6.A2 . Control del LED RGB con el potenciometro. Vamos a dividir el rango total en 8 partes y asignarle a cada una de ellas uno de los colores RGB seg\u00fan vemos en la tabla siguiente: Color Rango R G B Rojo 0 a 127 255 0 0 Verde 128 a 255 0 255 0 Azul 256 a 383 0 0 255 Amarillo 384 a 511 255 255 0 Cian 512 a 639 0 255 255 Magenta 640 a 767 255 0 255 Blanco 768 a 895 255 255 255 Naranja 896 a 1023 255 127 0 R6.A3 . (No reuelta) Repetir la actividad 2 de este reto 6 pero ahora adem\u00e1s mostrando por consola el valor del potenciometro. Soluci\u00f3n R6.A1 \u00b6 El bloque tiene unos signos + y - que tienen la misma funcionalidad que la ya vista anteriormente. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-06-A1 . Actividad 1 del reto 6 Cargamos, ejecutamos la consola y variando el potenciometro obtendremos resultados como el de la imagen siguiente: Consola de la actividad 1 del reto 6 Soluci\u00f3n R6.A2 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-06-A2 . Actividad 2 del reto 6","title":"Reto-06. Potenci\u00f3metro"},{"location":"R06/#reto-06-potenciometro","text":"","title":"Reto-06. Potenci\u00f3metro"},{"location":"R06/#enunciado","text":"Introducir el uso de las entradas anal\u00f3gicas para visualizar los cambios que hagamos con el potenciometro en el terminal serie o consola serie. Cuando hablamos de lecturas anal\u00f3gicas suele ser muy \u00fatil el uso del mapeo, concepto que tambi\u00e9n vamos a introducir y que veremos en la segunda parte del reto.","title":"Enunciado"},{"location":"R06/#teoria","text":"Antes de nada ya hemos indicado que el potenciometro va conectado a un pin anal\u00f3gico y es en este momento cuando vamos a establecer la diferencia entre los conceptos de anal\u00f3gico y de digital. Una clasificaci\u00f3n de los circuitos electr\u00f3nicos es dividirlos en dos grandes categor\u00edas: digitales y anal\u00f3gicos. La electr\u00f3nica digital utiliza magnitudes con dos valores discretos conocidos como 0 - 1, alto - bajo, on - off, etc, y que se corresponden con la presencia o no de tensi\u00f3n en un determinado punto. La electr\u00f3nica anal\u00f3gica emplea magnitudes con valores continuos. En concreto en las placas basadas en Arduino UNO, las entradas anal\u00f3gicas pueden tener 210 valores (10 bits de resoluci\u00f3n), es decir, valores comprendidos entre 0 y 1023. Estos valores se pueden expresar de forma num\u00e9rica o de forma porcentual, correspondiendo el 0 a un 0% y el 1023 al 100%.","title":"Teor\u00eda"},{"location":"R06/#el-potenciometro","text":"En la imagen siguiente vemos el aspecto de un modelo concreto de potenciometro as\u00ed como los s\u00edmbolos habituales del mismo. La numeraci\u00f3n indica lo siguiente: Terminales 1 y 3 son los contactos unidos a los extremos de la resistencia fija o resistencia total del potenciometro. Terminal 2 es el contacto que va unido al cursor o parte m\u00f3vil que se desliza sobre la resistencia fija haciendo que la resistencia entre un terminal y el cursor var\u00ede en funci\u00f3n de la posici\u00f3n de este. Aspecto y s\u00edmbolo del potenci\u00f3metro La posici\u00f3n del cursor se determina de forma mec\u00e1nica y son adecuados para usarlos como elementos de control de tensi\u00f3n (conexi\u00f3n en serie) o de corriente (conexi\u00f3n en paralelo). Los potenciometros del tipo que estamos viendo (existen de otros muchos tipos) tienen un funcionamiento en forma de rotaci\u00f3n con un \u00e1ngulo de unos 270 grados entre los puntos mas extremos.","title":"El potenci\u00f3metro"},{"location":"R06/#el-terminal-o-consola-serie","text":"Sirve para visualizar en un ordenador los datos recibidos a trav\u00e9s del puerto serie y en realidad es una aplicaci\u00f3n que controla las comunicaciones bidireccionales a trav\u00e9s de la UART integrada en el microcontrolador. Es muy importante tener siempre presente que el puerto serie es el que se utiliza para \"subir\" el firmware o programa a la placa, tarea que se realiza a trav\u00e9s de una aplicaci\u00f3n pregrabada en el microntrolador y que se denomina \"bootloader\". En ArduinoBlocks es posible usar la consola serie solamente si tenemos instalada y en funcionamiento la aplicaci\u00f3n ArduinoBlocks-Connector que es la encargada de establecer las comunicaciones locales de nuestra placa con las remotas de la aplicaci\u00f3n. En la imagen siguiente vemos el aspecto de la consola. Aspecto de la Consola en AB A la hora de establecer una conexi\u00f3n serie los dos extremos que intervienen en la conexi\u00f3n (placa UNO y ordenador) deben establecer el mismo valor en la velocidad de la conexi\u00f3n. Por defecto esta velocidad es de 9600 baudios o bits por segundo y otras velocidades comunmente utilizadas son: 4800, 19200, 38400, 57600, 115200. Es por lo tanto imprescindible incluir en el bloque \"Inicializar\" el bloque \"Iniciar\" y establecer la velocidad de comunicaci\u00f3n.","title":"El terminal o consola serie"},{"location":"R06/#serial-plotter-datalogger","text":"Es otra funcionalidad relacionada con la comunicaci\u00f3n serie que nos permite visualizar informaci\u00f3n en forma de gr\u00e1fica en tiempo real. Adem\u00e1s el \u201cSerial Plotter\u201d implementa un sencillo datalogger con el que podemos ir grabando los datos para exportarlos posteriormente. En ArduinoBlocks existen bloques que nos permiten trabajar con el serial plotter. El serial plotter + datalogger se activa haciendo clic en la flecha a la derecha de Consola y tiene el aspecto que vemos en la imagen siguiente: Serial Plotter + Datalogger","title":"Serial Plotter - Datalogger"},{"location":"R06/#mapeo","text":"Hemos indicado que las entradas anal\u00f3gicas trabajan con 10 bits, o sea valores comprendidos entre 0 y 1023 (210) y tambi\u00e9n que la salidas digitales trabajan con 8 bits, o sea valores entre 0 y 255 (28), por lo que si queremos combinar en nuestro programa entradas anal\u00f3gicas con salidas digitales debemos realizar un ajuste de escala en los datos. A este ajuste se le conoce como \"mapear\" y es un bloque disponible en el men\u00fa Matem\u00e1ticas con el aspecto de la imagen siguiente: Bloque mapear Este bloque permite modificar un valor o variable desde un rango origen a un rango destino. Esta funci\u00f3n es especialmente \u00fatil para adaptar los valores le\u00eddos de sensores o para adaptar valores a aplicar en un actuador.","title":"Mapeo"},{"location":"R06/#en-la-tdr-steam","text":"El potenciometro de la TdR STEAM","title":"En la TdR STEAM"},{"location":"R06/#programando-el-reto","text":"Parte 1 . Vamos a guardar los datos le\u00eddos del potenci\u00f3metro en una variable y mostrarlos a trav\u00e9s de la consola serie. La soluci\u00f3n al reto la tenemos disponible en Reto-06: Parte 1 que es el programa que vemos en la imagen siguiente: Parte 1 del reto 6 Si cargamos el programa en nuestra placa y posteriormente activamos la consola y conectamos ArduinoBlocks con nuestro ordenador podemos ver un resultado similar al de la imagen siguiente que se corresponde con variaciones de extremo a extremo del potenciometro. Aspecto de la consola Para entender el significado del check \"salto de linea\" del bloque \"Enviar\" podemos desactivarlo y volver a hacer el mismo proceso. Parte 2 . Vamos a modificar el programa de la parte 1 del reto para mapear los datos antes de enviarlos a la consola serie. La soluci\u00f3n al reto la tenemos disponible en Reto-06: Parte 2 que es el programa que vemos en la imagen siguiente: Parte 2 del reto 6 El resultado ahora lo vemos en la imagen siguiente: Aspecto de la consola Ampliaci\u00f3n . Vamos ahora a mapear y mostrar los datos le\u00eddos del potenci\u00f3metro en el Serial Plotter. La soluci\u00f3n al reto la tenemos disponible en Reto-06: Ampliacion que es el programa que vemos en la imagen siguiente: Ampliaci\u00f3n del reto 6, serial plotter Si activamos el Serial Plotter y vamos variando el potenciometro veremos el resultado en el mismo, obteniendo algo similar a la imagen siguiente: Aspecto del Serial Plotter","title":"Programando el reto"},{"location":"R06/#actividades-de-ampliacion","text":"R6.A1 . Utilizaci\u00f3n del bloque \"crear texto con ...\" del men\u00fa \"Texto\". Utilizaremos cualquiera de los programas vistos en el reto y configuraremos el nuevo bloque para que en cada l\u00ednea nos muestre el mensaje \"El valor del potenciometro es: \", a continuaci\u00f3n nos muestre el valor y tras el mismo el s\u00edmbolo % porque configuraremos la lectura en porcentaje. Dejaremos transcurrir un tiempo de 3s entre cada muestra de salida por consola. R6.A2 . Control del LED RGB con el potenciometro. Vamos a dividir el rango total en 8 partes y asignarle a cada una de ellas uno de los colores RGB seg\u00fan vemos en la tabla siguiente: Color Rango R G B Rojo 0 a 127 255 0 0 Verde 128 a 255 0 255 0 Azul 256 a 383 0 0 255 Amarillo 384 a 511 255 255 0 Cian 512 a 639 0 255 255 Magenta 640 a 767 255 0 255 Blanco 768 a 895 255 255 255 Naranja 896 a 1023 255 127 0 R6.A3 . (No reuelta) Repetir la actividad 2 de este reto 6 pero ahora adem\u00e1s mostrando por consola el valor del potenciometro.","title":"Actividades de ampliaci\u00f3n"},{"location":"R06/#solucion-r6a1","text":"El bloque tiene unos signos + y - que tienen la misma funcionalidad que la ya vista anteriormente. El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-06-A1 . Actividad 1 del reto 6 Cargamos, ejecutamos la consola y variando el potenciometro obtendremos resultados como el de la imagen siguiente: Consola de la actividad 1 del reto 6","title":"Soluci\u00f3n R6.A1"},{"location":"R06/#solucion-r6a2","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-06-A2 . Actividad 2 del reto 6","title":"Soluci\u00f3n R6.A2"},{"location":"R07/","text":"Reto-07. Fotorresistencia LDR \u00b6 Enunciado \u00b6 Utilizaremos la consola serie para mostrar los valores de luz detectados por la resistencia LDR o fotoc\u00e9lula. Teor\u00eda \u00b6 Una fotorresistencia o fotorresistor es un componente electr\u00f3nico cuya resistencia disminuye de forma exponencial con el aumento de la intensidad de luz incidente. Las siglas LDR vienen de su nombre en ingl\u00e9s, que es Light Dependent Resistor. En la imagen siguiente tenemos el s\u00edmbolo y el aspecto real de una LDR. Simbolo y aspecto de la LDR En la TdR STEAM \u00b6 La LDR en la TdR STEAM Programando el reto \u00b6 Dado que en el men\u00fa TDR STEAM de ArduinoBlocks tenemos disponible un bloque que nos devuelve el nivel de luz en porcentaje o de forma num\u00e9rica. La soluci\u00f3n al reto la tenemos disponible en Reto-07 que es el programa que vemos en la imagen siguiente: Reto 7 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce el Reto 7 Actividades de ampliaci\u00f3n \u00b6 R7.A1 . Programar un interruptor crepuscular utilizando la LDR y uno de los LEDs para simular el farol. El nivel de luz m\u00ednimo permitido antes de encender el farol es del 30%, de forma que con un valor menor o igual al 30% se enciena el LED y con un valor mayor permanezca apagado. Soluci\u00f3n R7.A1 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-07-A1 . Actividad 1 del reto 7","title":"Reto-07. Fotorresistencia LDR"},{"location":"R07/#reto-07-fotorresistencia-ldr","text":"","title":"Reto-07. Fotorresistencia LDR"},{"location":"R07/#enunciado","text":"Utilizaremos la consola serie para mostrar los valores de luz detectados por la resistencia LDR o fotoc\u00e9lula.","title":"Enunciado"},{"location":"R07/#teoria","text":"Una fotorresistencia o fotorresistor es un componente electr\u00f3nico cuya resistencia disminuye de forma exponencial con el aumento de la intensidad de luz incidente. Las siglas LDR vienen de su nombre en ingl\u00e9s, que es Light Dependent Resistor. En la imagen siguiente tenemos el s\u00edmbolo y el aspecto real de una LDR. Simbolo y aspecto de la LDR","title":"Teor\u00eda"},{"location":"R07/#en-la-tdr-steam","text":"La LDR en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R07/#programando-el-reto","text":"Dado que en el men\u00fa TDR STEAM de ArduinoBlocks tenemos disponible un bloque que nos devuelve el nivel de luz en porcentaje o de forma num\u00e9rica. La soluci\u00f3n al reto la tenemos disponible en Reto-07 que es el programa que vemos en la imagen siguiente: Reto 7 Esto nos generar\u00e1 algo como lo de la imagen siguiente en la consola: Consola que produce el Reto 7","title":"Programando el reto"},{"location":"R07/#actividades-de-ampliacion","text":"R7.A1 . Programar un interruptor crepuscular utilizando la LDR y uno de los LEDs para simular el farol. El nivel de luz m\u00ednimo permitido antes de encender el farol es del 30%, de forma que con un valor menor o igual al 30% se enciena el LED y con un valor mayor permanezca apagado.","title":"Actividades de ampliaci\u00f3n"},{"location":"R07/#solucion-r7a1","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-07-A1 . Actividad 1 del reto 7","title":"Soluci\u00f3n R7.A1"},{"location":"R08/","text":"Reto-08. Sensor de temperatura LM35 \u00b6 Enunciado \u00b6 Utilizaremos este sensor de temperatura para medir la temperatura de la habitaci\u00f3n en la que estemos resolviendo el reto mostrando el resultado en la consola. Teor\u00eda \u00b6 LM35 \u00b6 El LM35 es un circuito integrado de medida de temperatura de precisi\u00f3n con una tensi\u00f3n de salida lineal y proporcional a la temperatura en grados cent\u00edgrados. Algunas de las caracter\u00edsticas que se pueden extraer de la hoja de datos del LM35 son: Directamente calibrado en grados Celsius (Cent\u00edgrados) Factor de escala lineal de +10-mV/\u00b0C Resoluci\u00f3n asegurada de 0.5\u00b0C Rango de medida de \u221255\u00b0C a 150\u00b0C En la imagen siguiente vemos su representaci\u00f3n en circuito y el aspecto f\u00edsico que tiene en uno de sus encapsulados mas usual. Representaci\u00f3n esquem\u00e1tica y aspecto Bloques de tiempo \u00b6 Para este reto vamos a explicar los bloques de tiempo que se implementan en ArduinoBlocks. Las funciones de tiempo o retardo nos permiten realizar pausas y obtener informaci\u00f3n sobre el tiempo transcurrido dentro del microcontrolador. 1.- Bloques esperar . Realizan una pausa del tiempo que establezcamos hasta seguir con la ejecuci\u00f3n del siguiente bloque. Se corresponden con las instrucciones delay(1000) y delayMicroseconds(1000). Tenemos disponibles los dos de la imagen siguiente: Bloques esperar 2.- Tiempo transcurrido . Obtiene un valor con el tiempo transcurrido desde el inicio o reset del microcontrolador de la placa UNO. Se trata de las funciones millis() y micros(). El valor puede ser en milisegundos o microsegundos, tal y como vemos en la imagen siguiente: Bloques tiempo transcurrido En la imagen siguiente tenemos un ejemplo de uso sacado del manual del programa : Ejecutar la Tarea1 cada 3 segundos y la Tarea2 cada 7 segundos sin bloquear la ejecuci\u00f3n del programa : Ejemplo de uso del bloque tiempo transcurrido 3.- Esperar por siempre . Bloquea indefinidamente la ejecuci\u00f3n finalizando por tanto el programa. Vemos el bloque en la imagen siguiente: Bloque esperar por siempre 4.- Ejecutar cada . Es un bloque que NO bloquea la ejecuci\u00f3n del programa y que implementa autom\u00e1ticamente la funci\u00f3n millis(). En la imagen siguiente vemos su aspecto: Bloque ejecutar cada El resto de bloque y la ampliaci\u00f3n de informaci\u00f3n la podemos consultar en el manual del programa . Funciones \u00b6 Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas En la TdR STEAM \u00b6 El LM35 en la TdR STEAM Programando el reto \u00b6 La programaci\u00f3n del reto es muy similar a la de retos anteriores y el programa Reto-08 lo vemos en la imagen siguiente: Reto 8 En la imagen tenemos el aspecto de la consola: Consola del reto 8 Actividades de ampliaci\u00f3n \u00b6 R8.A1 . Alarma \u00f3ptico/ac\u00fastica por sobrepasar una temperatura de 25\u00baC. Utilizaremos el zumbador para emitir alg\u00fan pitido y el LED rojo para la indicaci\u00f3n \u00f3ptica. R8.A2 . Sem\u00e1foro indicador de rangos de temperatura. Se trata de programar un sem\u00e1foro con un LED RGB que mostrar\u00e1 color verde si la temperatura est\u00e1 por debajo de 25\u00baC, rojo si est\u00e1 por encima de 35\u00baC y amarillo si est\u00e1 entre ambos valores. Soluci\u00f3n R8.A1 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-08-A1 . El LED parpadear\u00e1 y el zumbador emitir\u00e1 los dos sonidos establecidos si la temperatura detectada por el LM35 est\u00e1 por encima de los 25\u00baC. Actividad 1 del reto 8 Soluci\u00f3n R8.A2 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-08-A2 . Actividad 2 del reto 8","title":"Reto-08. Sensor de temperatura LM35"},{"location":"R08/#reto-08-sensor-de-temperatura-lm35","text":"","title":"Reto-08. Sensor de temperatura LM35"},{"location":"R08/#enunciado","text":"Utilizaremos este sensor de temperatura para medir la temperatura de la habitaci\u00f3n en la que estemos resolviendo el reto mostrando el resultado en la consola.","title":"Enunciado"},{"location":"R08/#teoria","text":"","title":"Teor\u00eda"},{"location":"R08/#lm35","text":"El LM35 es un circuito integrado de medida de temperatura de precisi\u00f3n con una tensi\u00f3n de salida lineal y proporcional a la temperatura en grados cent\u00edgrados. Algunas de las caracter\u00edsticas que se pueden extraer de la hoja de datos del LM35 son: Directamente calibrado en grados Celsius (Cent\u00edgrados) Factor de escala lineal de +10-mV/\u00b0C Resoluci\u00f3n asegurada de 0.5\u00b0C Rango de medida de \u221255\u00b0C a 150\u00b0C En la imagen siguiente vemos su representaci\u00f3n en circuito y el aspecto f\u00edsico que tiene en uno de sus encapsulados mas usual. Representaci\u00f3n esquem\u00e1tica y aspecto","title":"LM35"},{"location":"R08/#bloques-de-tiempo","text":"Para este reto vamos a explicar los bloques de tiempo que se implementan en ArduinoBlocks. Las funciones de tiempo o retardo nos permiten realizar pausas y obtener informaci\u00f3n sobre el tiempo transcurrido dentro del microcontrolador. 1.- Bloques esperar . Realizan una pausa del tiempo que establezcamos hasta seguir con la ejecuci\u00f3n del siguiente bloque. Se corresponden con las instrucciones delay(1000) y delayMicroseconds(1000). Tenemos disponibles los dos de la imagen siguiente: Bloques esperar 2.- Tiempo transcurrido . Obtiene un valor con el tiempo transcurrido desde el inicio o reset del microcontrolador de la placa UNO. Se trata de las funciones millis() y micros(). El valor puede ser en milisegundos o microsegundos, tal y como vemos en la imagen siguiente: Bloques tiempo transcurrido En la imagen siguiente tenemos un ejemplo de uso sacado del manual del programa : Ejecutar la Tarea1 cada 3 segundos y la Tarea2 cada 7 segundos sin bloquear la ejecuci\u00f3n del programa : Ejemplo de uso del bloque tiempo transcurrido 3.- Esperar por siempre . Bloquea indefinidamente la ejecuci\u00f3n finalizando por tanto el programa. Vemos el bloque en la imagen siguiente: Bloque esperar por siempre 4.- Ejecutar cada . Es un bloque que NO bloquea la ejecuci\u00f3n del programa y que implementa autom\u00e1ticamente la funci\u00f3n millis(). En la imagen siguiente vemos su aspecto: Bloque ejecutar cada El resto de bloque y la ampliaci\u00f3n de informaci\u00f3n la podemos consultar en el manual del programa .","title":"Bloques de tiempo"},{"location":"R08/#funciones","text":"Una funci\u00f3n permite crear un grupo de bloques de c\u00f3digo que realizan una determinada tarea y que se repite a lo largo del programa en varias ocasiones. Con la creaci\u00f3n de una funci\u00f3n evitamos repetir todos esos bloques y simplemente tendremos que invocar a la funci\u00f3n. Es muy conveniente que los nombre que usemos sean lo mas descriptivos posibles de lo que hace la funci\u00f3n. Existen dos tipos de funciones: las que no retornan un valor y las que si lo hacen. En la imagen siguiente vemos los bloques correspondientes a las mismas: Bloques para crear funciones en ArduinoBlocks Cuando creamos funciones autom\u00e1ticamente se crea el bloque con su nombre que permite invocarla, tal y como vemos en la imagen siguiente: Bloques para llamada a funciones Tambi\u00e9n es posible crear funciones a las que se le env\u00edan datos o par\u00e1metros haciendo uso del signo + que aparece en los bloques. En la imagen siguiente vemos como le hemos a\u00f1adido un par de par\u00e1metros a cada tipo de funci\u00f3n y como se han modificado sus respectivos bloques de invocaci\u00f3n. Bloques para llamada a funciones con par\u00e1metros Un ejemplo t\u00edpico descriptivo del funcionamiento de las funciones es el de calculo del \u00e1rea de un tri\u00e1ngulo. Para ello definimos la funci\u00f3n que realiza el c\u00e1lculo, le pasamos dos par\u00e1metros, la base y la altura, realizamos los c\u00e1lculos pitag\u00f3ricos y nos devuelve el \u00e1rea del tri\u00e1ngulo para esos datos. En la imagen siguiente tenemos la idea de resoluci\u00f3n con la funci\u00f3n creada y el bloque para llamarla. Ejemplo de calculo del \u00e1rea de un tri\u00e1ngulo En las im\u00e1genes siguiente vemos como se han creado diferentes funciones y la forma de llamarlas. En concreto se corresponden con la base del programa de Educacont para configurar y grabar en la correspondiente estaci\u00f3n. La primera funci\u00f3n es \"leer sensores\" y la vemos en la imagen siguiente: Funci\u00f3n leer sensores de Educacont En la imagen siguiente podemos ver la funci\u00f3n encargada de subir los datos le\u00eddos a la nube. Funci\u00f3n subir datos a la nube de Educacont La siguiente funci\u00f3n permite detener las mediciones durante 15 minutos. Funci\u00f3n detener medici\u00f3n nn minutos de Educacont El bucle principal tiene la configuraci\u00f3n que vemos en la imagen siguiente: Llamada a las funciones definidas","title":"Funciones"},{"location":"R08/#en-la-tdr-steam","text":"El LM35 en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R08/#programando-el-reto","text":"La programaci\u00f3n del reto es muy similar a la de retos anteriores y el programa Reto-08 lo vemos en la imagen siguiente: Reto 8 En la imagen tenemos el aspecto de la consola: Consola del reto 8","title":"Programando el reto"},{"location":"R08/#actividades-de-ampliacion","text":"R8.A1 . Alarma \u00f3ptico/ac\u00fastica por sobrepasar una temperatura de 25\u00baC. Utilizaremos el zumbador para emitir alg\u00fan pitido y el LED rojo para la indicaci\u00f3n \u00f3ptica. R8.A2 . Sem\u00e1foro indicador de rangos de temperatura. Se trata de programar un sem\u00e1foro con un LED RGB que mostrar\u00e1 color verde si la temperatura est\u00e1 por debajo de 25\u00baC, rojo si est\u00e1 por encima de 35\u00baC y amarillo si est\u00e1 entre ambos valores.","title":"Actividades de ampliaci\u00f3n"},{"location":"R08/#solucion-r8a1","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-08-A1 . El LED parpadear\u00e1 y el zumbador emitir\u00e1 los dos sonidos establecidos si la temperatura detectada por el LM35 est\u00e1 por encima de los 25\u00baC. Actividad 1 del reto 8","title":"Soluci\u00f3n R8.A1"},{"location":"R08/#solucion-r8a2","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-08-A2 . Actividad 2 del reto 8","title":"Soluci\u00f3n R8.A2"},{"location":"R09/","text":"Reto-09. Sensor de temperatura/humedad DHT-11 \u00b6 Enunciado \u00b6 Realizar un programa b\u00e1sico de medida de temperatura y humedad relativa de la habitaci\u00f3n en la que estamos trabajando con nuestra TdR STEAM. Teor\u00eda \u00b6 El DHT11 es un modelo de sensor que permiten realizar la medici\u00f3n simult\u00e1nea de temperatura y humedad. Dispone de un procesador interno que es el encargado de realizar la medici\u00f3n entregando la informaci\u00f3n mediante una se\u00f1al digital. Se presenta en un encapsulado pl\u00e1stico caracter\u00edstico de color azul. Sus principales caracter\u00edsticas son: Rango de temperatura: 0 a 50\u00baC Precisi\u00f3n de la medida de temperatura: \u00b12\u00baC Rango de humedad: 20 a 80% Precisi\u00f3n en la medida de humedad: \u00b15%. Frecuencia de muestreo: 1 muestra por segundo (1 Hz) El DHT11 es un sensor bastante limitado que podemos usar con fines de formaci\u00f3n, pruebas, o en proyectos que realmente no requieran una medici\u00f3n precisa. Si necesitamos mayor precisi\u00f3n y rango podemos recurrir al DHT22 que es de la misma familia y lo \u00fanico que cambia es sus caracter\u00edsticas y el precio. Sus caracter\u00edsticas son: Rango de temperatura: -40 a 125\u00baC Precisi\u00f3n de la medida de temperatura: \u00b10.5\u00baC Rango de humedad: 0 a 100% Precisi\u00f3n en la medida de humedad: \u00b12 a 5% Frecuencia de muestreo: 2 muestras por segundo (2 Hz) En la imagen siguiente vemos el aspecto de ambos sensores: Aspecto DHT11 y DHT22 En la TdR STEAM \u00b6 El DHT11 en la TdR STEAM Programando el reto \u00b6 De nuevo realizaremos la programaci\u00f3n del reto como en los retos anteriores y el programa Reto-09 lo vemos en la imagen siguiente: Programa del Reto 9 Actividades de ampliaci\u00f3n \u00b6 R9.A1 . Realizar un programa que nos muestre el estado de confort seg\u00fan las explicaciones que se dan a continuaci\u00f3n y la idea del sem\u00e1foro vista en la actividad 2 del Reto 8. En la web ARQUITECTURA & ENERG\u00cdA podemos encontrar un art\u00edculo donde se nos explica con bastante profundad el tema del corfort t\u00e9rmico . Puede definirse confort t\u00e9rmico, o m\u00e1s propiamente comodidad higrot\u00e9rmica, como la ausencia de malestar t\u00e9rmico. En fisiolog\u00eda, se dice que hay confort higrot\u00e9rmico cuando no tienen que intervenir los mecanismos termorreguladores del cuerpo para una actividad sedentaria y con una indumentaria ligera. Esta situaci\u00f3n puede registrarse mediante \u00edndices que no deben ser sobrepasados para que no se pongan en funcionamiento los sistemas termorreguladores (metabolismo, sudoraci\u00f3n y otros). En la imagen siguiente vemos los valores de temperatura y humedad que delimitan las zonas de confortabilidad. Confort t\u00e9rmico en funci\u00f3n de temperatura y humedad Sobre el gr\u00e1fico vamos a delimitar zonas de temperatura y humedad para establecer su color. Por motivos de simplicidad lo vamos a hacer delimitando zonas rectangulares, pero comprobamos que no cometemos grandes errores y para nuestro prop\u00f3sito nos sirve. 1.- Zona Roja : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: superior al 85% e inferior al 20% Temperatura: superior a 27 e inferior a 16\u00baC Delimitaci\u00f3n color rojo zona de confort 2.- Zona Amarilla : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: entre el 20% y el 40% y entre el 65% y el 85% Temperatura: entre 16\u00baC y 18\u00baC y entre 24\u00baC y 27\u00baC Delimitaci\u00f3n color amarillo zona de confort 3.- Zona Verde, rojo y amarillo : en la imagen siguiente tenemos delimitadas todas las zonas, correspondiendo a la verde los siguientes datos: Humedad Relativa: entre el 40% y el 65% Temperatura: entre 18\u00baC y 24\u00baC Delimitaci\u00f3n colores zona de confort En este enlace al archivo colores-R9.A1.svg puedes ver como se han realizado estos gr\u00e1ficos. Actividades de ampliaci\u00f3n \u00b6 R9.Actividad-propuesta . Idear m\u00e9todo para probar de forma completa la funcionalidad del programa anterior. Si es necesario se modifica el programa. Tambi\u00e9n se pide explicar la misi\u00f3n de la funci\u00f3n \"limite-confort\". Soluci\u00f3n R9.A1 \u00b6 Para resolver la actividad vamos a necesitar varios bloques del men\u00fa \"L\u00f3gica\" y especialmente combinando funciones AND y OR multiples. Si necesitamos, por ejemplo, aumentar el n\u00famero de operadores AND dentro de un bloque simplemente tenemos que combinarlo como vemos en la imagen siguiente, donde se han combinado cuatro bloques AND. Combinacion de 4 bloques AND El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-09-A1 . Actividad 1 del reto 9","title":"Reto-09. Sensor de temperatura y humedad DHT-11"},{"location":"R09/#reto-09-sensor-de-temperaturahumedad-dht-11","text":"","title":"Reto-09. Sensor de temperatura/humedad DHT-11"},{"location":"R09/#enunciado","text":"Realizar un programa b\u00e1sico de medida de temperatura y humedad relativa de la habitaci\u00f3n en la que estamos trabajando con nuestra TdR STEAM.","title":"Enunciado"},{"location":"R09/#teoria","text":"El DHT11 es un modelo de sensor que permiten realizar la medici\u00f3n simult\u00e1nea de temperatura y humedad. Dispone de un procesador interno que es el encargado de realizar la medici\u00f3n entregando la informaci\u00f3n mediante una se\u00f1al digital. Se presenta en un encapsulado pl\u00e1stico caracter\u00edstico de color azul. Sus principales caracter\u00edsticas son: Rango de temperatura: 0 a 50\u00baC Precisi\u00f3n de la medida de temperatura: \u00b12\u00baC Rango de humedad: 20 a 80% Precisi\u00f3n en la medida de humedad: \u00b15%. Frecuencia de muestreo: 1 muestra por segundo (1 Hz) El DHT11 es un sensor bastante limitado que podemos usar con fines de formaci\u00f3n, pruebas, o en proyectos que realmente no requieran una medici\u00f3n precisa. Si necesitamos mayor precisi\u00f3n y rango podemos recurrir al DHT22 que es de la misma familia y lo \u00fanico que cambia es sus caracter\u00edsticas y el precio. Sus caracter\u00edsticas son: Rango de temperatura: -40 a 125\u00baC Precisi\u00f3n de la medida de temperatura: \u00b10.5\u00baC Rango de humedad: 0 a 100% Precisi\u00f3n en la medida de humedad: \u00b12 a 5% Frecuencia de muestreo: 2 muestras por segundo (2 Hz) En la imagen siguiente vemos el aspecto de ambos sensores: Aspecto DHT11 y DHT22","title":"Teor\u00eda"},{"location":"R09/#en-la-tdr-steam","text":"El DHT11 en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R09/#programando-el-reto","text":"De nuevo realizaremos la programaci\u00f3n del reto como en los retos anteriores y el programa Reto-09 lo vemos en la imagen siguiente: Programa del Reto 9","title":"Programando el reto"},{"location":"R09/#actividades-de-ampliacion","text":"R9.A1 . Realizar un programa que nos muestre el estado de confort seg\u00fan las explicaciones que se dan a continuaci\u00f3n y la idea del sem\u00e1foro vista en la actividad 2 del Reto 8. En la web ARQUITECTURA & ENERG\u00cdA podemos encontrar un art\u00edculo donde se nos explica con bastante profundad el tema del corfort t\u00e9rmico . Puede definirse confort t\u00e9rmico, o m\u00e1s propiamente comodidad higrot\u00e9rmica, como la ausencia de malestar t\u00e9rmico. En fisiolog\u00eda, se dice que hay confort higrot\u00e9rmico cuando no tienen que intervenir los mecanismos termorreguladores del cuerpo para una actividad sedentaria y con una indumentaria ligera. Esta situaci\u00f3n puede registrarse mediante \u00edndices que no deben ser sobrepasados para que no se pongan en funcionamiento los sistemas termorreguladores (metabolismo, sudoraci\u00f3n y otros). En la imagen siguiente vemos los valores de temperatura y humedad que delimitan las zonas de confortabilidad. Confort t\u00e9rmico en funci\u00f3n de temperatura y humedad Sobre el gr\u00e1fico vamos a delimitar zonas de temperatura y humedad para establecer su color. Por motivos de simplicidad lo vamos a hacer delimitando zonas rectangulares, pero comprobamos que no cometemos grandes errores y para nuestro prop\u00f3sito nos sirve. 1.- Zona Roja : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: superior al 85% e inferior al 20% Temperatura: superior a 27 e inferior a 16\u00baC Delimitaci\u00f3n color rojo zona de confort 2.- Zona Amarilla : en la imagen siguiente tenemos delimitadas las zonas: Humedad Relativa: entre el 20% y el 40% y entre el 65% y el 85% Temperatura: entre 16\u00baC y 18\u00baC y entre 24\u00baC y 27\u00baC Delimitaci\u00f3n color amarillo zona de confort 3.- Zona Verde, rojo y amarillo : en la imagen siguiente tenemos delimitadas todas las zonas, correspondiendo a la verde los siguientes datos: Humedad Relativa: entre el 40% y el 65% Temperatura: entre 18\u00baC y 24\u00baC Delimitaci\u00f3n colores zona de confort En este enlace al archivo colores-R9.A1.svg puedes ver como se han realizado estos gr\u00e1ficos.","title":"Actividades de ampliaci\u00f3n"},{"location":"R09/#actividades-de-ampliacion_1","text":"R9.Actividad-propuesta . Idear m\u00e9todo para probar de forma completa la funcionalidad del programa anterior. Si es necesario se modifica el programa. Tambi\u00e9n se pide explicar la misi\u00f3n de la funci\u00f3n \"limite-confort\".","title":"Actividades de ampliaci\u00f3n"},{"location":"R09/#solucion-r9a1","text":"Para resolver la actividad vamos a necesitar varios bloques del men\u00fa \"L\u00f3gica\" y especialmente combinando funciones AND y OR multiples. Si necesitamos, por ejemplo, aumentar el n\u00famero de operadores AND dentro de un bloque simplemente tenemos que combinarlo como vemos en la imagen siguiente, donde se han combinado cuatro bloques AND. Combinacion de 4 bloques AND El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-09-A1 . Actividad 1 del reto 9","title":"Soluci\u00f3n R9.A1"},{"location":"R10/","text":"Reto-10. Emisor y receptor de infrarrojos \u00b6 Enunciado \u00b6 Enviaremos c\u00f3digos desde el control remoto por infrarrojos que ser\u00e1n recibidos por el LED de infrarrojos para actuar seg\u00fan el c\u00f3digo recibido. Teor\u00eda \u00b6 \u00bfque son los infrarrojos? \u00b6 Son una clase de radiaci\u00f3n electromagn\u00e9tica con una longitud de onda que resulta superior a la longitud de onda de la luz visible, siendo su frecuencia superior a las microondas. Dentro del espectro electromagn\u00e9tico, la radiaci\u00f3n infrarroja se encuentra comprendida entre el espectro de luz visible y las microondas. Tiene longitudes de onda mayores o m\u00e1s largas que el rojo. En la imagen siguiente, obtenida del blog de Mercedes Gonz\u00e1lez Mas vemos caracterizados los infrarrojos dentro del espectro. Espectro electromagnetico Como podemos observar en la imagen, los rayos infrarrojos son clasificados, de acuerdo a su longitud de onda, del siguiente modo: infrarrojo cercano, con longitud de onda entre 0.7 \u00b5m y 1.1 \u00b5m, es la parte del espectro infrarrojo que ese encuentra m\u00e1s pr\u00f3ximo a la luz visible. infrarrojo medio, con longitud de onda entre 1,1 \u00b5m y 15 \u00b5m. infrarrojo lejano o regi\u00f3n m\u00e1s cercana a las microondas, con longitud de onda entre 15 \u00b5m y 100 \u00b5m En la imagen siguiente, obtenida de wikipedia , sobre espectro electromagn\u00e9tico podemos ver m\u00e1s informaci\u00f3n del tema. Espectro electromagnetico Todos los cuerpos emiten una cierta cantidad de radiaci\u00f3n, y aunque esta resulta invisible para el ojo humano, existen dispositivos electr\u00f3nicos capaces de \"verla\" por estar dise\u00f1ados para ello. Receptor de infrarrojos \u00b6 Uno de los receptores m\u00e1s universal utilizado en placas tipo Arduino es el receptor de infrarrojos universal TL1838, VS1838B o simplemente 1835 de 38KHz, cuyo aspecto podemos ver en la imagen siguiente: Diodo IR 1838 En el datasheet TL1838 del dispositivo tenemos toda la informaci\u00f3n sobre el mismo destacando las siguientes caracter\u00edsticas: Voltaje de funcionamiento: 2.7V a 5.5V Frecuencia: 37.9KHz \u00c1ngulo de recepci\u00f3n: 90\u00b0 Rango de recepci\u00f3n: 18m El dispositivo genera una se\u00f1al de salida que sirve para controles remotos universales y utiliza la codificaci\u00f3n NEC. El receptor de infrarrojos permite codificar los protocolos de se\u00f1ales de pulsos infrarrojos utilizados por los mandos a distancia. Los protocolos detectados son los siguientes: RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA, LG, SANYO, MITSUBISHI y DENON. Es decir, detectar\u00eda cualquier se\u00f1al emitida por cualquiera de esos mandos. Emisor de infrarrojos \u00b6 En nuestro caso como emisor de infrarrojos vamos a utilizar el control remoto de Keyestudio que vemos en la imagen siguiente: Control remoto El mini control remoto tiene 17 teclas de funci\u00f3n y tiene las siguientes especificaciones: Bater\u00eda: pilas de bot\u00f3n CR2025 Distancia de transmisi\u00f3n: hasta 8 m \u00c1ngulo efectivo: 60\u00b0 El control remoto, o mando a distancia, por IR funciona emitiendo trenes de pulsos de luz infrarroja. Diferentes se\u00f1ales corresponden a botones diferentes La se\u00f1al infrarroja transmite el c\u00f3digo correspondiente al bot\u00f3n del mando a distancia pulsado al dispositivo en forma de una serie de impulsos de luz infrarroja. El receptor recibe la serie de impulsos de infrarrojos y los pasa a un procesador que decodifica y activar\u00e1n una determinada funci\u00f3n del dispositivo. En el reto y las actividades del mismo obtendremos estos c\u00f3digos. En arduinoBlocks se han asignado los siguientes nombres a las teclas: Nombre teclas control remoto en ArduinoBlocks Bloques en ArduinoBlocks \u00b6 El sensor receptor de infrarrojos permite obtener la cadena de texto con el c\u00f3digo en formato hexadecimal correspondiente al tren de pulsos de IR generado al pulsar una determinada tecla. El bloque es el que vemos en la imagen siguiente: En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM El valor devuelto por el bloque de recepci\u00f3n ser\u00e1 una cadena de texto con valor vac\u00edo en caso de no detectar ning\u00fan c\u00f3digo. Al devolver el bloque una cadena de texto debemos recordar que lo tenemos que almacenar en una variable de tipo texto. Si utilizamos mandos gen\u00e9ricos RC5 como el modelo de Keyestudio, podemos usar el bloque de la imagen siguiente para comparar los c\u00f3digos recibidos y as\u00ed identificar f\u00e1cilmente cada tecla. En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM En la TdR STEAM \u00b6 El sensor receptor de IR en la TdR STEAM Programando el reto \u00b6 Vamos a realizar un programa en el que si pulsamos la tecla Ok del control remoto se nos encienda el diodo LED rojo.La soluci\u00f3n al reto la tenemos disponible en Reto-10 que es el programa que vemos en la imagen siguiente: Reto 10 Actividades de ampliaci\u00f3n \u00b6 R10.A1 . Realizar un programa que encienda el LED RGB en los colores establecidos a continuaci\u00f3n y seg\u00fan la tecla flecha pulsada. Flecha arriba = Rojo Flecha izquierda = Verde Flecha derecha = Amarillo Flecha abajo = azul R10.A2 . Realizar un programa que nos muestre por consola el c\u00f3digo hexadecimal correspondiente a cada una de las teclas pulsadas junto a un texto descriptivo indicar de la tecla pulsada en cada caso, es decir, que mantenga una estructura del tipo: El CODIGO se corresponde con la tecla TECLA pulsada. Soluci\u00f3n R10.A1 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-10-A1 . Actividad 1 del reto 10 Soluci\u00f3n R10.A2 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-10-A2 . Se han contraido todos los bloques para que todo el programa entre en una sola pantalla, siendo en cada caso similares a los dos expandidos, el del condicional y el de la funci\u00f3n. Actividad 2 del reto 10 El resultado en la consola de pulsar sucesivamente todas las teclas lo vemos en la imagen siguiente: Consola de la actividad 2 del reto 10","title":"Reto-10. Emisor y receptor de infrarrojos"},{"location":"R10/#reto-10-emisor-y-receptor-de-infrarrojos","text":"","title":"Reto-10. Emisor y receptor de infrarrojos"},{"location":"R10/#enunciado","text":"Enviaremos c\u00f3digos desde el control remoto por infrarrojos que ser\u00e1n recibidos por el LED de infrarrojos para actuar seg\u00fan el c\u00f3digo recibido.","title":"Enunciado"},{"location":"R10/#teoria","text":"","title":"Teor\u00eda"},{"location":"R10/#que-son-los-infrarrojos","text":"Son una clase de radiaci\u00f3n electromagn\u00e9tica con una longitud de onda que resulta superior a la longitud de onda de la luz visible, siendo su frecuencia superior a las microondas. Dentro del espectro electromagn\u00e9tico, la radiaci\u00f3n infrarroja se encuentra comprendida entre el espectro de luz visible y las microondas. Tiene longitudes de onda mayores o m\u00e1s largas que el rojo. En la imagen siguiente, obtenida del blog de Mercedes Gonz\u00e1lez Mas vemos caracterizados los infrarrojos dentro del espectro. Espectro electromagnetico Como podemos observar en la imagen, los rayos infrarrojos son clasificados, de acuerdo a su longitud de onda, del siguiente modo: infrarrojo cercano, con longitud de onda entre 0.7 \u00b5m y 1.1 \u00b5m, es la parte del espectro infrarrojo que ese encuentra m\u00e1s pr\u00f3ximo a la luz visible. infrarrojo medio, con longitud de onda entre 1,1 \u00b5m y 15 \u00b5m. infrarrojo lejano o regi\u00f3n m\u00e1s cercana a las microondas, con longitud de onda entre 15 \u00b5m y 100 \u00b5m En la imagen siguiente, obtenida de wikipedia , sobre espectro electromagn\u00e9tico podemos ver m\u00e1s informaci\u00f3n del tema. Espectro electromagnetico Todos los cuerpos emiten una cierta cantidad de radiaci\u00f3n, y aunque esta resulta invisible para el ojo humano, existen dispositivos electr\u00f3nicos capaces de \"verla\" por estar dise\u00f1ados para ello.","title":"\u00bfque son los infrarrojos?"},{"location":"R10/#receptor-de-infrarrojos","text":"Uno de los receptores m\u00e1s universal utilizado en placas tipo Arduino es el receptor de infrarrojos universal TL1838, VS1838B o simplemente 1835 de 38KHz, cuyo aspecto podemos ver en la imagen siguiente: Diodo IR 1838 En el datasheet TL1838 del dispositivo tenemos toda la informaci\u00f3n sobre el mismo destacando las siguientes caracter\u00edsticas: Voltaje de funcionamiento: 2.7V a 5.5V Frecuencia: 37.9KHz \u00c1ngulo de recepci\u00f3n: 90\u00b0 Rango de recepci\u00f3n: 18m El dispositivo genera una se\u00f1al de salida que sirve para controles remotos universales y utiliza la codificaci\u00f3n NEC. El receptor de infrarrojos permite codificar los protocolos de se\u00f1ales de pulsos infrarrojos utilizados por los mandos a distancia. Los protocolos detectados son los siguientes: RC5, RC6, NEC, SONY, PANASONIC, JVC, SAMSUNG, WHYNTER, AIWA, LG, SANYO, MITSUBISHI y DENON. Es decir, detectar\u00eda cualquier se\u00f1al emitida por cualquiera de esos mandos.","title":"Receptor de infrarrojos"},{"location":"R10/#emisor-de-infrarrojos","text":"En nuestro caso como emisor de infrarrojos vamos a utilizar el control remoto de Keyestudio que vemos en la imagen siguiente: Control remoto El mini control remoto tiene 17 teclas de funci\u00f3n y tiene las siguientes especificaciones: Bater\u00eda: pilas de bot\u00f3n CR2025 Distancia de transmisi\u00f3n: hasta 8 m \u00c1ngulo efectivo: 60\u00b0 El control remoto, o mando a distancia, por IR funciona emitiendo trenes de pulsos de luz infrarroja. Diferentes se\u00f1ales corresponden a botones diferentes La se\u00f1al infrarroja transmite el c\u00f3digo correspondiente al bot\u00f3n del mando a distancia pulsado al dispositivo en forma de una serie de impulsos de luz infrarroja. El receptor recibe la serie de impulsos de infrarrojos y los pasa a un procesador que decodifica y activar\u00e1n una determinada funci\u00f3n del dispositivo. En el reto y las actividades del mismo obtendremos estos c\u00f3digos. En arduinoBlocks se han asignado los siguientes nombres a las teclas: Nombre teclas control remoto en ArduinoBlocks","title":"Emisor de infrarrojos"},{"location":"R10/#bloques-en-arduinoblocks","text":"El sensor receptor de infrarrojos permite obtener la cadena de texto con el c\u00f3digo en formato hexadecimal correspondiente al tren de pulsos de IR generado al pulsar una determinada tecla. El bloque es el que vemos en la imagen siguiente: En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM El valor devuelto por el bloque de recepci\u00f3n ser\u00e1 una cadena de texto con valor vac\u00edo en caso de no detectar ning\u00fan c\u00f3digo. Al devolver el bloque una cadena de texto debemos recordar que lo tenemos que almacenar en una variable de tipo texto. Si utilizamos mandos gen\u00e9ricos RC5 como el modelo de Keyestudio, podemos usar el bloque de la imagen siguiente para comparar los c\u00f3digos recibidos y as\u00ed identificar f\u00e1cilmente cada tecla. En proyectos que no usen la TdR STEAM En proyectos con TdR STEAM","title":"Bloques en ArduinoBlocks"},{"location":"R10/#en-la-tdr-steam","text":"El sensor receptor de IR en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R10/#programando-el-reto","text":"Vamos a realizar un programa en el que si pulsamos la tecla Ok del control remoto se nos encienda el diodo LED rojo.La soluci\u00f3n al reto la tenemos disponible en Reto-10 que es el programa que vemos en la imagen siguiente: Reto 10","title":"Programando el reto"},{"location":"R10/#actividades-de-ampliacion","text":"R10.A1 . Realizar un programa que encienda el LED RGB en los colores establecidos a continuaci\u00f3n y seg\u00fan la tecla flecha pulsada. Flecha arriba = Rojo Flecha izquierda = Verde Flecha derecha = Amarillo Flecha abajo = azul R10.A2 . Realizar un programa que nos muestre por consola el c\u00f3digo hexadecimal correspondiente a cada una de las teclas pulsadas junto a un texto descriptivo indicar de la tecla pulsada en cada caso, es decir, que mantenga una estructura del tipo: El CODIGO se corresponde con la tecla TECLA pulsada.","title":"Actividades de ampliaci\u00f3n"},{"location":"R10/#solucion-r10a1","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-10-A1 . Actividad 1 del reto 10","title":"Soluci\u00f3n R10.A1"},{"location":"R10/#solucion-r10a2","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-10-A2 . Se han contraido todos los bloques para que todo el programa entre en una sola pantalla, siendo en cada caso similares a los dos expandidos, el del condicional y el de la funci\u00f3n. Actividad 2 del reto 10 El resultado en la consola de pulsar sucesivamente todas las teclas lo vemos en la imagen siguiente: Consola de la actividad 2 del reto 10","title":"Soluci\u00f3n R10.A2"},{"location":"R11/","text":"Reto-11. Puerto de expansi\u00f3n I2C. La LCD de 2x16 \u00b6 Enunciado \u00b6 Utilizaremos las comunicaciones I2C para mostrar textos en la pantalla LCD I2C incluida en el kit. Teor\u00eda \u00b6 Las comunicaciones I2C \u00b6 Dado que la placa TdR STEAM dispone de un puerto de expansi\u00f3n I2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado) vamos a explicar un poco en que consiste este sistema de conexionado. Bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el marte prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo. La LCD 1602 \u00b6 Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la imagen siguiente. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa UNO para su control. En la imagen siguiente se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo: 4 bits para datos y dos se\u00f1ales de control En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar las que tienen el aspecto que vemos en la imagen siguiente: LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenciometro de ajuste de contraste. Esta pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo, que en el caso de la que incorpora el kit TdR STEAM es la 0x27, pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado y se muestra el sistema de distribuci\u00f3n de filas y columnas. Bloques para imprimir en un par fila-columna Sistema de coordenadas en una LCD 1602 Escanear dispositivos I2C \u00b6 Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto, en esta ocasi\u00f3n, de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la imagen siguiente: Menu I2C Un sencillo programa como el de la imagen siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Escaner-I2C . Programa Escaner-I2C Si conectamos la consola el resultado de tener la placa TdR STEAM es el de la imagen siguiente: Consola para el programa Escaner-I2C Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C \u00b6 Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Direcci\u00f3n 0x26 Definici\u00f3n de s\u00edmbolos en la LCD \u00b6 Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la imagen en la siguiente: Ejemplo de simbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque. En la TdR STEAM \u00b6 En la placa TdR STEAM tenemos el conector I2C con los mismo pines de conexi\u00f3n que la LCD y debemos respetar el orden de conexionado indicado en la siguiente tabla: TdR STEAM LCD 1602 Color cable GND GND Negro Vcc Vcc Rojo SDA SDA Amarillo SCL SCL Blanco La ubicaci\u00f3n del conector I2C en la TdR STEAM lo vemos en la imagen siguiente: Conector I2C en la TdR STEAM Programando el reto \u00b6 Como primer ejemplo de uso vamos a mostrar una informaci\u00f3n determinada en la pantalla LCD, en concreto vamos a mostrar cuatro textos en ambas filas que se ir\u00e1n alternando cada tres segundos en la pantalla. El programa de la imagen siguiente lo tenemos disponible en Reto-11 . Reto 11 Actividades de ampliaci\u00f3n \u00b6 R11.A1 . Corregir el error ortogr\u00e1fico en la palabra \"Robotica\" del Reto 11. Para ello tenemos que definir nuestro propio s\u00edmbolo de \"\u00f3\" (o acentuada). R11.A2 . Realizar un control de iluminaci\u00f3n del LED RGB mediante PWM y mostrar por pantalla el valor de la iluminaci\u00f3n en cada instante. Se realizar\u00e1 el control desde el m\u00ednimo de iluminaci\u00f3n a m\u00e1ximo y cuando se alcance el m\u00e1ximo bajamos otra vez a m\u00ednimo. Soluci\u00f3n R11.A1 \u00b6 Definimos el s\u00edmbolo requerido tal y como vemos en la imagen siguiente: S\u00edmbolo o acentuada El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-11-A1 . Actividad 1 del reto 11 Soluci\u00f3n R11.A2 \u00b6 El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-11-A2 . Se ha resuelto con un contador ascendente y otro descendente sobre el LED rojo. Se pueden probar diferentes opciones de LEDs o incluso combinaci\u00f3n de ellas. Tambi\u00e9n se anima al lector a comprobar que ocurre si quitamos la opci\u00f3n \"N\u00famero entero\" y ponemos directamente la variable del bucle y buscar la explicaci\u00f3n. Actividad 2 del reto 11","title":"Reto-11. Puerto de expansi\u00f3n I2C. La LCD de 2x16"},{"location":"R11/#reto-11-puerto-de-expansion-i2c-la-lcd-de-2x16","text":"","title":"Reto-11. Puerto de expansi\u00f3n I2C. La LCD de 2x16"},{"location":"R11/#enunciado","text":"Utilizaremos las comunicaciones I2C para mostrar textos en la pantalla LCD I2C incluida en el kit.","title":"Enunciado"},{"location":"R11/#teoria","text":"","title":"Teor\u00eda"},{"location":"R11/#las-comunicaciones-i2c","text":"Dado que la placa TdR STEAM dispone de un puerto de expansi\u00f3n I2C (del ingl\u00e9s Inter-Integrated Circuit = Circuito inter-integrado) vamos a explicar un poco en que consiste este sistema de conexionado. Bus conocido por las siglas I2C, IIC o I\u00b2C, es un bus serie de datos desarrollado en 1982 por Philips Semiconductors (hoy NXP Semiconductors, parte de Qualcomm). Se utiliza principalmente internamente para la comunicaci\u00f3n entre diferentes partes de un circuito, por ejemplo, entre un controlador y circuitos perif\u00e9ricos integrados. Posteriormente fue adoptado progresivamente por otros fabricantes hasta convertirse en un est\u00e1ndar del mercado con miles de circuitos integrados de diferentes fabricantes. I2C tambi\u00e9n se denomina TWI (Two Wired Interface) \u00fanicamente por motivos de licencia, denominaci\u00f3n introducida por Atmel. No obstante, la patente caduc\u00f3 en 2006, por lo que actualmente no hay restricci\u00f3n sobre el uso del t\u00e9rmino I2C. El bus I2C requiere \u00fanicamente dos cables o lineas de se\u00f1al para su funcionamiento, uno para la se\u00f1al de reloj (SCL, Serial Clock) y otro para el env\u00edo de datos (SDA, Serial Data). Ambas l\u00edneas precisan resistencias de pull-up hacia Vcc. Cualquier dispositivo conectado a estas l\u00edneas es de drenador o colector abierto (Open Collector), lo cual en combinaci\u00f3n con las resistencias pull-up, crea un circuito Wired-AND. En la imagen siguiente vemos el diagrama b\u00e1sico de conexionado del bus con algunos ejemplos de dispositivos. La se\u00f1al de reloj siempre es generada por el circuito que act\u00faa como Master. Diagrama de conexi\u00f3n del bus I2C Para ser reconocido en el bus, cada dispositivo dispone de una direcci\u00f3n, que se emplea para acceder a cada uno de ellos de forma individual. Esta direcci\u00f3n puede ser fijada por hardware, en cuyo caso se pueden modificar los \u00faltimos 3 bits mediante \u201cjumpers\u201d o microinterruptores (ejemplo de la matriz de 8x8), o por software. En general, cada dispositivo conectado al bus debe tener una direcci\u00f3n \u00fanica. Si tenemos varios dispositivos similares tendremos que cambiar la direcci\u00f3n o, en caso de no ser posible, implementar un bus secundario. El bus I2C tiene una arquitectura de tipo master-slave, lo que indica que el master es el encargado de controlar al resto de dispositivos tipo slave con los que se comunica y que se comunican con el, teniendo siempre el marte prioridad absoluta. El dispositivo master es el que inicia la comunicaci\u00f3n con los slaves. Los slaves no pueden iniciar la comunicaci\u00f3n (el master tiene que preguntarles), ni hablar entre si directamente. El bus I2C debe ser por lo tanto s\u00edncrono, es decir debe existir una se\u00f1al de reloj que controle las comunicaciones. Es el master el que proporciona la se\u00f1al de reloj, que mantiene sincronizados a todos los dispositivos del bus. De esta forma, se elimina la necesidad de que cada dispositivo tenga su propio reloj, de tener que acordar una velocidad de transmisi\u00f3n y mecanismos para mantener la transmisi\u00f3n sincronizada como en UART o SPI. En la imagen vemos un cronograma ejemplo del funcionamiento del sistema. Cronograma trabajo bus I2C El protocolo de comunicaci\u00f3n I2C sigue la siguiente secuencia: Primero, el master genera la se\u00f1al de reloj del bus (SCL). Se inicia la comunicaci\u00f3n por orden del master al establecer la condici\u00f3n de START, que se produce cuando SDA pasa de uno a cero y se mantiene en cero durante un tiempo. El master direcciona a los slaves. El master indica si se va a leer o escribir. El slave direccionado responde con una se\u00f1al de conformidad ACK (acknowledge). Se transmite los datos byte a byte desde SDA al receptor. Por cada pulso desde SCL se transmite un bit de informaci\u00f3n. El destinatario de la informaci\u00f3n responde con una se\u00f1al de conformidad ACK. Se acaba la comunicaci\u00f3n cuando el master establece la condici\u00f3n de STOP, que se produce cuando SDA, por orden del master pasa de cero a uno y se mantiene en uno durante un tiempo. Son muchos los dispositivos I2C que se pueden direccionar por este bus I2C, siendo lo m\u00e1s com\u00fan en los dispositivos para I2C que utilicen direcciones de 7 bits, aunque existen dispositivos de 10 bits, pero es un caso raro. Una direcci\u00f3n de 7 bits implica que se pueden poner hasta 128 (27) dispositivos sobre un bus I2C. Hemos visto que las direcciones son de 8 bits y esto es porque el bit extra de los 7 de la direcci\u00f3n lo emplea el master para informar al slave si va a leer o escribir. Si el bit de lectura/escritura es cero, el dispositivo master est\u00e1 escribiendo en el slave. Si el bit es 1 el master est\u00e1 leyendo desde el slave. La direcci\u00f3n de 7 bit se coloca en los 7 bits m\u00e1s significativos del byte y el bit de lectura/escritura es el bit menos significativo.","title":"Las comunicaciones I2C"},{"location":"R11/#la-lcd-1602","text":"Una pantalla LCD (del ing\u00e9s, Liquid Cristal Display) de 2 l\u00edneas de 16 caracteres tiene el aspecto y la distribuci\u00f3n de pines que vemos en la imagen siguiente. LCD 2x16 Es evidente que deber\u00edamos utilizar bastantes patillas de nuestra placa UNO para su control. En la imagen siguiente se muestra el conexionado m\u00ednimo necesario en una pantalla de este tipo: 4 bits para datos y dos se\u00f1ales de control En (Enable) y Rs (Register select). La conexi\u00f3n RW la ponemos a GND. Adem\u00e1s se debe a\u00f1adir una resistencia ajustable o un potenci\u00f3metro para regular el contraste de la pantalla. Conexionado m\u00ednimo LCD 2x16 Es preferible utilizar las que tienen el aspecto que vemos en la imagen siguiente: LCD 2x16 con m\u00f3dulo I2C En realidad el conjunto que vemos en la imagen anterior no es mas que una LCD 2x16 a la que se ha incorporado un m\u00f3dulo adaptador de LCD a I2C. Este modulo est\u00e1 especialmente dise\u00f1ado para poder soldarlo directamente a la LCD y convertirla as\u00ed en un dispositivo I2C que adem\u00e1s ya lleva incorporado el potenciometro de ajuste de contraste. Esta pantalla requiere cuatro cables para establecer las conexiones, dos cables SDA (datos) y SCL (reloj) para el bus de comunicaciones I2C y los dos cables de alimentaci\u00f3n VCC y GND. La direcci\u00f3n I2C por defecto de este tipo de m\u00f3dulos puede ser 0x3F o en otros casos 0x27, e incluso hay modelos en los que se puede cambiar. Para un correcto control es muy importante identificar correctamente la direcci\u00f3n I2C de nuestro modulo, que en el caso de la que incorpora el kit TdR STEAM es la 0x27, pues de otra forma nuestro programa no funcionar\u00e1 correctamente. Una LCD 1602 I2C es muy sencilla de controlar a partir de los bloques que nos proporciona ArduinoBlocks. En la imagen siguiente ponemos como ejemplo los bloques para imprimir un texto o variable en un par fila-columna determinado y se muestra el sistema de distribuci\u00f3n de filas y columnas. Bloques para imprimir en un par fila-columna Sistema de coordenadas en una LCD 1602","title":"La LCD 1602"},{"location":"R11/#escanear-dispositivos-i2c","text":"Si no conocemos la direcci\u00f3n especifica de nuestro m\u00f3dulo podemos utilizar un peque\u00f1o programa que llamaremos Escaner-I2C y que se encargar\u00e1 de identificar la direcci\u00f3n I2C y todos los dispositivos I2C conectados a nuestra placa. Debemos crear un proyecto, en esta ocasi\u00f3n, de tipo \"Arduino UNO\" para tener disponible el men\u00fa I2C que nos de acceso al bloque \"Escanear dispositivos I2C...\" tal y como vemos en la imagen siguiente: Menu I2C Un sencillo programa como el de la imagen siguiente nos permite ver los dispositivos I2C conectados y su direcci\u00f3n f\u00edsica asociada. El programa est\u00e1 disponible como Escaner-I2C . Programa Escaner-I2C Si conectamos la consola el resultado de tener la placa TdR STEAM es el de la imagen siguiente: Consola para el programa Escaner-I2C","title":"Escanear dispositivos I2C"},{"location":"R11/#cambiar-la-direccion-fisica-del-dispositivo-i2c","text":"Esta tarea nos va a resultar especialmente \u00fatil si disponemos de LCDs I2C con una direcci\u00f3n fijada de f\u00e1brica y queremos conectar varias de ellas en nuestro proyecto. La parte posterior de la LCD 1602 de Keyestudio tiene el aspecto de la imagen siguiente. Nos fijaremos especialmente en los tres grupos de agujeros enmarcados en rojo. Aunque en este caso no vienen nombrados los vamos a denominar A0, A1 y A2 de izquierda a derecha. Pads configuraci\u00f3n direcci\u00f3n f\u00edsica en la parte posterior LCD I2C La direcci\u00f3n por defecto de f\u00e1brica en este caso es la 0x27, pero se puede cambiar alterando la situaci\u00f3n de conexionado de estos agujeros entre si seg\u00fan la tabla siguiente: A2 A1 A0 Direcci\u00f3n 0 0 0 0x27 0 0 1 0x26 0 1 0 0x25 0 1 1 0x24 1 0 0 0x23 1 0 1 0x22 1 1 0 0x21 1 1 1 0x20 Para establecer los unos de la tabla anterior basta con cortocircuitar los dos pads correspondientes. En la imagen siguiente se ha establecido la direcci\u00f3n f\u00edsica como 0x26. Direcci\u00f3n 0x26","title":"Cambiar la direcci\u00f3n f\u00edsica del dispositivo I2C"},{"location":"R11/#definicion-de-simbolos-en-la-lcd","text":"Dentro de los bloques del men\u00fa Visualizaci\u00f3n -> Pantalla LCD est\u00e1 el de \"definir s\u00edmbolo\", que permite definir uno de los 8 s\u00edmbolos personalizables que puede almacenar la pantalla LCD. El s\u00edmbolo se define por un mapa de bits (unos y ceros indicando cada p\u00edxel del s\u00edmbolo). Los s\u00edmbolos tienen una resoluci\u00f3n de 5x8 p\u00edxeles (blanco o negro). En ArduinoBlocks disponemos de una herramienta que nos ayuda a definir nuestros propios s\u00edmbolos y podemos acceder a ella desde herramientas o haciendo clic derecho sobre el bloque, despleg\u00e1ndose en cualquier caso un editor muy sencillo de usar y que vemos con un ejemplo en la imagen en la siguiente: Ejemplo de simbolo creado con el editor Para tener el s\u00edmbolo disponible simplemente copiamos la cadena generada en el lugar correspondiente del bloque.","title":"Definici\u00f3n de s\u00edmbolos en la LCD"},{"location":"R11/#en-la-tdr-steam","text":"En la placa TdR STEAM tenemos el conector I2C con los mismo pines de conexi\u00f3n que la LCD y debemos respetar el orden de conexionado indicado en la siguiente tabla: TdR STEAM LCD 1602 Color cable GND GND Negro Vcc Vcc Rojo SDA SDA Amarillo SCL SCL Blanco La ubicaci\u00f3n del conector I2C en la TdR STEAM lo vemos en la imagen siguiente: Conector I2C en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R11/#programando-el-reto","text":"Como primer ejemplo de uso vamos a mostrar una informaci\u00f3n determinada en la pantalla LCD, en concreto vamos a mostrar cuatro textos en ambas filas que se ir\u00e1n alternando cada tres segundos en la pantalla. El programa de la imagen siguiente lo tenemos disponible en Reto-11 . Reto 11","title":"Programando el reto"},{"location":"R11/#actividades-de-ampliacion","text":"R11.A1 . Corregir el error ortogr\u00e1fico en la palabra \"Robotica\" del Reto 11. Para ello tenemos que definir nuestro propio s\u00edmbolo de \"\u00f3\" (o acentuada). R11.A2 . Realizar un control de iluminaci\u00f3n del LED RGB mediante PWM y mostrar por pantalla el valor de la iluminaci\u00f3n en cada instante. Se realizar\u00e1 el control desde el m\u00ednimo de iluminaci\u00f3n a m\u00e1ximo y cuando se alcance el m\u00e1ximo bajamos otra vez a m\u00ednimo.","title":"Actividades de ampliaci\u00f3n"},{"location":"R11/#solucion-r11a1","text":"Definimos el s\u00edmbolo requerido tal y como vemos en la imagen siguiente: S\u00edmbolo o acentuada El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-11-A1 . Actividad 1 del reto 11","title":"Soluci\u00f3n R11.A1"},{"location":"R11/#solucion-r11a2","text":"El Programa de la imagen siguiente est\u00e1 disponible en el enlace Reto-11-A2 . Se ha resuelto con un contador ascendente y otro descendente sobre el LED rojo. Se pueden probar diferentes opciones de LEDs o incluso combinaci\u00f3n de ellas. Tambi\u00e9n se anima al lector a comprobar que ocurre si quitamos la opci\u00f3n \"N\u00famero entero\" y ponemos directamente la variable del bucle y buscar la explicaci\u00f3n. Actividad 2 del reto 11","title":"Soluci\u00f3n R11.A2"},{"location":"R12/","text":"Reto-12. Sensor de sonido o micr\u00f3fono \u00b6 Enunciado \u00b6 Realizaremos pruebas b\u00e1sicas de detecci\u00f3n de nivel de sonido a\u00f1adiendo esta opci\u00f3n externa al pin anal\u00f3gico A3 disponible en el conector correspondiente. Teor\u00eda Un micro\u0301fono es un transductor (dispositivo que convierte energi\u0301a de una forma a otra) que convierte la energi\u0301a sonora en sen\u0303ales ele\u0301ctricas. Micro\u0301fonos hay una amplia diversidad tanto en formas como taman\u0303os. Dependiendo de la aplicacio\u0301n, un micro\u0301fono puede utilizar diferentes tecnologi\u0301as para convertir sonidos en sen\u0303ales ele\u0301ctricas. Para el caso de aplicaciones con placas tipo Arduino suelen usarse sensores basados en el micro\u0301fono de condensador electret que es un condensador de placas paralelas y trabaja como una capacitancia variable. Se forma con una placa fija (placa trasera) y una movible (diafragma) con una pequen\u0303a separacio\u0301n entre ellas. Cuando el sonido golpea al diafragma este se mueve cambiando asi\u0301 la capacitancia entre las placas. El sensor microf\u00f3nico de keyestudio se utiliza normalmente para detectar el nivel de ruido en el ambiente. El pin S del mismo es una salida anal\u00f3gica, es decir, una tensi\u00f3n de salida en tiempo real del micr\u00f3fono. El sensor viene con un potenci\u00f3metro que permite ajustar la ganancia de la se\u00f1al dentro de un determinado rango. Su aspecto es el de la imagen siguiente: Sensor de sonido con micr\u00f3fono KS0035 con potenci\u00f3metro En la TdR STEAM \u00b6 El conector micr\u00f3fono externo en A3 Programando el reto \u00b6 Como programa sencillo inicial vamos simplemente a enviar a la consola el nivel de sonido que detecte nuestro micr\u00f3fono. El programa de la imagen siguiente esta disponible como Reto-12 . Reto 12 Actividades de ampliaci\u00f3n \u00b6 R12.A1 . (No resuelta): Modificar el programa del reto 12 para que muestre los datos por la LCD R12.A2 . (No resuelta): Modificar la actividad A1 para que muestre los datos tanto por la consola como por la LCD. R12.A3 . (No resuelta): Partiendo del programa de la actividad 2 del reto 11 modificarlo para que muestre los datos del micr\u00f3fono tanto al final de la cuenta ascendente como de la descendente.","title":"Reto-12. Sensor de sonido o micr\u00f3fono"},{"location":"R12/#reto-12-sensor-de-sonido-o-microfono","text":"","title":"Reto-12. Sensor de sonido o micr\u00f3fono"},{"location":"R12/#enunciado","text":"Realizaremos pruebas b\u00e1sicas de detecci\u00f3n de nivel de sonido a\u00f1adiendo esta opci\u00f3n externa al pin anal\u00f3gico A3 disponible en el conector correspondiente. Teor\u00eda Un micro\u0301fono es un transductor (dispositivo que convierte energi\u0301a de una forma a otra) que convierte la energi\u0301a sonora en sen\u0303ales ele\u0301ctricas. Micro\u0301fonos hay una amplia diversidad tanto en formas como taman\u0303os. Dependiendo de la aplicacio\u0301n, un micro\u0301fono puede utilizar diferentes tecnologi\u0301as para convertir sonidos en sen\u0303ales ele\u0301ctricas. Para el caso de aplicaciones con placas tipo Arduino suelen usarse sensores basados en el micro\u0301fono de condensador electret que es un condensador de placas paralelas y trabaja como una capacitancia variable. Se forma con una placa fija (placa trasera) y una movible (diafragma) con una pequen\u0303a separacio\u0301n entre ellas. Cuando el sonido golpea al diafragma este se mueve cambiando asi\u0301 la capacitancia entre las placas. El sensor microf\u00f3nico de keyestudio se utiliza normalmente para detectar el nivel de ruido en el ambiente. El pin S del mismo es una salida anal\u00f3gica, es decir, una tensi\u00f3n de salida en tiempo real del micr\u00f3fono. El sensor viene con un potenci\u00f3metro que permite ajustar la ganancia de la se\u00f1al dentro de un determinado rango. Su aspecto es el de la imagen siguiente: Sensor de sonido con micr\u00f3fono KS0035 con potenci\u00f3metro","title":"Enunciado"},{"location":"R12/#en-la-tdr-steam","text":"El conector micr\u00f3fono externo en A3","title":"En la TdR STEAM"},{"location":"R12/#programando-el-reto","text":"Como programa sencillo inicial vamos simplemente a enviar a la consola el nivel de sonido que detecte nuestro micr\u00f3fono. El programa de la imagen siguiente esta disponible como Reto-12 . Reto 12","title":"Programando el reto"},{"location":"R12/#actividades-de-ampliacion","text":"R12.A1 . (No resuelta): Modificar el programa del reto 12 para que muestre los datos por la LCD R12.A2 . (No resuelta): Modificar la actividad A1 para que muestre los datos tanto por la consola como por la LCD. R12.A3 . (No resuelta): Partiendo del programa de la actividad 2 del reto 11 modificarlo para que muestre los datos del micr\u00f3fono tanto al final de la cuenta ascendente como de la descendente.","title":"Actividades de ampliaci\u00f3n"},{"location":"R13/","text":"Reto-13. Termohigr\u00f3metro \u00b6 Enunciado \u00b6 Utilizando el sensor de temperatura y humedad DHT11, el LED RGB y la LCD vamos a construir un higr\u00f3metro capaz de detectar si la humedad es superior al 80% y la temperatura los 20\u00baC, en cuyo caso se encender\u00e1 en rojo el LED RGB y si es inferior de color verde. Deber\u00e1 mostrar los datos de temperatura y humedad en la pantalla LCD. Programando el reto \u00b6 El programa de la imagen siguiente resuelve el reto 13 y est\u00e1 disponible en Reto-13 . Reto 13 Actividad propuesta \u00b6 R13.A1 . Mostrar y exportar los datos con el datalogger y analizar la exportaci\u00f3n mediante una gr\u00e1fica realizada en hoja de c\u00e1lculo a partir de los datos exportados. Soluci\u00f3n R13.A1 \u00b6 El programa es el mismo que el el del reto 13 a\u00f1adiendo la inicializaci\u00f3n de la conexi\u00f3n serie y enviando los dos datos al Plotter, lo vemos en la imagen siguiente y est\u00e1 disponible en R13.A1 . Actividad 1 del reto 13 En el Serial Plotter veremos algo similar a lo siguiente: Captura del Serial Plotter Una vez cargados los datos de temperatura y humedad en una hoja de c\u00e1lculo y realizada una gr\u00e1fica de los mismo tenemos algo similar a lo que vemos en la imagen siguiente: Los datos del Higr\u00f3metro en una hoja de c\u00e1lculo En el archivo Reto-13.zip est\u00e1n los datos exportados y la hoja de c\u00e1lculo con el an\u00e1lisis realizado.","title":"Reto-13. Termohigr\u00f3metro"},{"location":"R13/#reto-13-termohigrometro","text":"","title":"Reto-13. Termohigr\u00f3metro"},{"location":"R13/#enunciado","text":"Utilizando el sensor de temperatura y humedad DHT11, el LED RGB y la LCD vamos a construir un higr\u00f3metro capaz de detectar si la humedad es superior al 80% y la temperatura los 20\u00baC, en cuyo caso se encender\u00e1 en rojo el LED RGB y si es inferior de color verde. Deber\u00e1 mostrar los datos de temperatura y humedad en la pantalla LCD.","title":"Enunciado"},{"location":"R13/#programando-el-reto","text":"El programa de la imagen siguiente resuelve el reto 13 y est\u00e1 disponible en Reto-13 . Reto 13","title":"Programando el reto"},{"location":"R13/#actividad-propuesta","text":"R13.A1 . Mostrar y exportar los datos con el datalogger y analizar la exportaci\u00f3n mediante una gr\u00e1fica realizada en hoja de c\u00e1lculo a partir de los datos exportados.","title":"Actividad propuesta"},{"location":"R13/#solucion-r13a1","text":"El programa es el mismo que el el del reto 13 a\u00f1adiendo la inicializaci\u00f3n de la conexi\u00f3n serie y enviando los dos datos al Plotter, lo vemos en la imagen siguiente y est\u00e1 disponible en R13.A1 . Actividad 1 del reto 13 En el Serial Plotter veremos algo similar a lo siguiente: Captura del Serial Plotter Una vez cargados los datos de temperatura y humedad en una hoja de c\u00e1lculo y realizada una gr\u00e1fica de los mismo tenemos algo similar a lo que vemos en la imagen siguiente: Los datos del Higr\u00f3metro en una hoja de c\u00e1lculo En el archivo Reto-13.zip est\u00e1n los datos exportados y la hoja de c\u00e1lculo con el an\u00e1lisis realizado.","title":"Soluci\u00f3n R13.A1"},{"location":"R14/","text":"Reto-14. Bluetooth \u00b6 Enunciado \u00b6 Crear una aplicaci\u00f3n para comunicarnos por Bluetooth con la placa TdR STEAM desde nuestro m\u00f3vil. Teor\u00eda \u00b6 En la placa TDR STEAM tenemos disponible un puerto de comunicaciones serie que nos permite conectar m\u00f3dulos Bluetooth o Wifi. Este puerto va equipado de un interruptor para poder conectarlo o desconectarlo ya que utiliza los mismos pines Rx/Tx que se utilizan para comunicarse con el ordenador. En la imagen siguiente vemos el puerto y el interruptor y la conexi\u00f3n que se realiza seg\u00fan la posici\u00f3n del interruptor. Puerto BT y WiFi y posici\u00f3n interruptor M\u00f3dulo Bluetooth \u00b6 Bluetooth es una especificaci\u00f3n industrial para Redes Inal\u00e1mbricas de \u00c1rea Personal (WPAN) que posibilita la transmisi\u00f3n de voz y datos entre diferentes dispositivos mediante un enlace por radiofrecuencia en la banda ISM de los 2.4 GHz. Los principales objetivos que se pretenden conseguir con esta norma son: Facilitar las comunicaciones entre equipos m\u00f3viles. Eliminar los cables y conectores entre estos. Ofrecer la posibilidad de crear peque\u00f1as redes inal\u00e1mbricas y facilitar la sincronizaci\u00f3n de datos entre equipos personales. Se denomina Bluetooth al protocolo de comunicaciones dise\u00f1ado especialmente para dispositivos de bajo consumo, que requieren corto alcance de emisi\u00f3n y basados en transceptores (dispositivos que cuentan con transmisor y receptor compartiendo parte de la circuiter\u00eda) de bajo costo. El hardware que compone el dispositivo Bluetooth est\u00e1 compuesto por dos partes: un dispositivo de radio, encargado de modular y transmitir la se\u00f1al. un controlador digital, compuesto por una CPU, un procesador de se\u00f1ales digitales (DSP \u2013 Digital Signal Processor) llamado Link Controller (o controlador de Enlace) y de las interfaces con el dispositivo anfitri\u00f3n. Existe un procedimiento definido que se llama Pairing (o emparejamiento) que vincula a dos dispositivos Bluetooth. Cuando vinculamos dos dispositivos Bluetooth, se inicia un proceso en el que ellos se identifican por nombre y direcci\u00f3n interna y se solicitan la clave PIN para autorizar la conexi\u00f3n. Si el emparejamiento se realiza con \u00e9xito, ambos nodos suelen guardar la identificaci\u00f3n del otro y cuando se encuentran cerca se vuelven a vincular sin necesidad de intervenci\u00f3n manual. Para manejar los m\u00f3dulos Bluetooth se utilizan los comandos Hayes o AT, de los que puedes encontrar informaci\u00f3n en este enlace y a continuaci\u00f3n damos algunos b\u00e1sicos: AT+VERSION: Versi\u00f3n del Firmware. AT+NAMEXXX: Para establecer el nombre que queremos presentar cuando otro dispositivo nos busque. AT+PINXXXX: permite establecer el n\u00famero de identificaci\u00f3n personal, que se requerir\u00e1 para establecer la vinculaci\u00f3n. AT+BAUDX: Permite fijar la velocidad de comunicaci\u00f3n entre el modulo y la consola seg\u00fan los siguientes pares: 1 -> 1200 bps | -5 -> 19200 bps 2 -> 2400 bps | -6 -> 38400 bps 3 -> 4800 bps | -7 -> 57600 bps 4 -> 9600 bps | -8 -> 115200 bps La velocidad por defecto es la de 9600 bps. Los m\u00f3dulos mas conocidosson el HC-05 y HC-06 que son Bluetooth V2 y cuyo aspecto podemos ver en la imagen siguiente: M\u00f3dulos HC-05 y HC-06 Para poder hacer la comunicaci\u00f3n por Bluetooth con nuestra placa Imagina TdR STEAM tenemos que conectar un m\u00f3dulo Bluetooth en el conector de comunicaciones serie. En nuestro caso utilizaremos un m\u00f3dulo HC-06. En la TdR STEAM \u00b6 El puerto de comunicaciones Rx/Tx en la TdR STEAM Es muy importante poner el interruptor en la posici\u00f3n adecuada seg\u00fan queramos funcionar en modo Bluetooth o programar la placa UNO. Recordemos que: Interruptor en posici\u00f3n OFF: para grabar firmware desde ArduinoBlocks. Interruptor en posici\u00f3n ON: modo Bluetooth. Programando el reto \u00b6 Vamos a necesitar dos programas para poder trabajar, a saber: Un programa que haga funcionar la placa UNO con la shield TdR STEAM que programaremos desde ArduinoBlocks. Una aplicaci\u00f3n que funcionar\u00e1 en nuestro tel\u00e9fono m\u00f3vil que programaremos con AppInventor2. Programa en AppInventor2 \u00b6 No vamos a entrar en detalles sobre el tema y simplemente expondremos el proceso que seguimos paso a paso. Lo primero que debemos hacer es crear una cuenta, si no la tenemos ya, y loguearnos en MIT App Inventor. Una vez hecho esto procedemos a crear nuestra aplicaci\u00f3n tanto en \"Designer\" como en \"Blocks\". Este es el paso a paso seguido: Paso 1 : Configuramos \"Designer\" para que tenga el aspecto que vemos en la imagen siguiente: Designer en AppInventor Se han colocado un ListPicker, dos botones y un cliente de Bluettoth sobre un nuevo proyecto creado desde la paleta de componentes. El ListPicker se ha renombrado y se ha establecido que su anchura se adapte a su contenedor (Fill parent) y a cada uno de los botones se le ha modificado el texto por defecto para que sea el que se ve en la imagen. El componente BluetoothClient no ser\u00e1 visible en la APP. Paso 2 : Nos cambiamos al modo programaci\u00f3n haciendo clic sobre el bot\u00f3n Blocks en la esquina superior derecha. Vamos localizando y configurando los distintos bloques que vemos en la imagen siguiente, que no es otra cosa que la programaci\u00f3n de nuestra aplicaci\u00f3n para m\u00f3vil. Como observamos el sistema es totalmente similar al de ArduinoBlocks por lo que no debe resultarnos especialmente dif\u00edcil localizar los bloques. Programa por bloques de nuestra APP Programa en ArduinoBlocks \u00b6 Paso 3 : Creamos el programa siguiente en ArduinoBlocks. El programa en ArduinoBlocks del Reto 14 Proceso de prueba \u00b6 Una vez tenemos los dos programas preparados continuamos con el paso a paso. Paso 4 : Cargamos el programa de ArduinoBlocks en la placa UNO. Para ello debemos asegurarnos, si tenemos el m\u00f3dulo Bluetooth colocado, de poner el interruptor en la posici\u00f3n OFF o no podremos programar nuestra placa. Muy probablemente la aplicaci\u00f3n se quedar\u00e1 colgada y no nos dejar\u00e1 hacer nada oblig\u00e1ndonos a reiniciar el equipo. Paso 5 : Instalar la aplicaci\u00f3n en el tel\u00e9fono m\u00f3vil. En mi caso he ido al men\u00fa \"Build\" y he escogido \"Android App (.apk). Tras un proceso que dura unos segundos se nos muestra en pantalla una ventana emergente como la de la imagen siguiente. Podemos escanear el c\u00f3digo QR directamente desde el m\u00f3vil y seguir los pasos de instalaci\u00f3n que se nos muestren o descargar desde el bot\u00f3n \"Download\" y proceder a la instalaci\u00f3n. Opciones de descarga de Android App Paso 6 : Sincronizar el Bluetooth del m\u00f3vil con el m\u00f3dulo Bluetooth de la placa UNO. Para ello Conectamos y Abrimos el servicio Bluetooth del m\u00f3vil y buscamos el nuevo dispositivo. Elegimos el que corresponda a nuestro caso e introducimos la contrase\u00f1a que normalmente ser\u00e1 1234 aunque opcionalmente puede ser 0000. Paso 7 : Abrimos la aplicaci\u00f3n, que en este caso se llama TdR-STEAM. Probar la funcionalidad del bot\u00f3n conectar que inicialmente tendr\u00e1 las letras de color negro, nos saldr\u00e1 el dispositivo con el que estamos emparejados, y las letras del bot\u00f3n \"Conectar\" cambian al color establecido en la programaci\u00f3n y a luz del m\u00f3dulo Bluetooth de la placa Imagina TDR STEAM quedar\u00e1 fija (hasta ahora ha estado parpadeando) en el color rojo. Es MUY IMPORTANTE comprobar que el interruptor ahora est\u00e1 en la posici\u00f3n ON en la placa Imagina TdR STEAM. Si pulsamos sobre el bot\u00f3n LED ON se encender\u00e1 el LED azul y si pulsamos sobre el bot\u00f3n LED OFF se apagar\u00e1. El programa de ArduinoBlocks lo tenemos disponible en Reto-14 y el de App Inventor en App-TdR-STEAM .","title":"Reto-14. Bluetooth"},{"location":"R14/#reto-14-bluetooth","text":"","title":"Reto-14. Bluetooth"},{"location":"R14/#enunciado","text":"Crear una aplicaci\u00f3n para comunicarnos por Bluetooth con la placa TdR STEAM desde nuestro m\u00f3vil.","title":"Enunciado"},{"location":"R14/#teoria","text":"En la placa TDR STEAM tenemos disponible un puerto de comunicaciones serie que nos permite conectar m\u00f3dulos Bluetooth o Wifi. Este puerto va equipado de un interruptor para poder conectarlo o desconectarlo ya que utiliza los mismos pines Rx/Tx que se utilizan para comunicarse con el ordenador. En la imagen siguiente vemos el puerto y el interruptor y la conexi\u00f3n que se realiza seg\u00fan la posici\u00f3n del interruptor. Puerto BT y WiFi y posici\u00f3n interruptor","title":"Teor\u00eda"},{"location":"R14/#modulo-bluetooth","text":"Bluetooth es una especificaci\u00f3n industrial para Redes Inal\u00e1mbricas de \u00c1rea Personal (WPAN) que posibilita la transmisi\u00f3n de voz y datos entre diferentes dispositivos mediante un enlace por radiofrecuencia en la banda ISM de los 2.4 GHz. Los principales objetivos que se pretenden conseguir con esta norma son: Facilitar las comunicaciones entre equipos m\u00f3viles. Eliminar los cables y conectores entre estos. Ofrecer la posibilidad de crear peque\u00f1as redes inal\u00e1mbricas y facilitar la sincronizaci\u00f3n de datos entre equipos personales. Se denomina Bluetooth al protocolo de comunicaciones dise\u00f1ado especialmente para dispositivos de bajo consumo, que requieren corto alcance de emisi\u00f3n y basados en transceptores (dispositivos que cuentan con transmisor y receptor compartiendo parte de la circuiter\u00eda) de bajo costo. El hardware que compone el dispositivo Bluetooth est\u00e1 compuesto por dos partes: un dispositivo de radio, encargado de modular y transmitir la se\u00f1al. un controlador digital, compuesto por una CPU, un procesador de se\u00f1ales digitales (DSP \u2013 Digital Signal Processor) llamado Link Controller (o controlador de Enlace) y de las interfaces con el dispositivo anfitri\u00f3n. Existe un procedimiento definido que se llama Pairing (o emparejamiento) que vincula a dos dispositivos Bluetooth. Cuando vinculamos dos dispositivos Bluetooth, se inicia un proceso en el que ellos se identifican por nombre y direcci\u00f3n interna y se solicitan la clave PIN para autorizar la conexi\u00f3n. Si el emparejamiento se realiza con \u00e9xito, ambos nodos suelen guardar la identificaci\u00f3n del otro y cuando se encuentran cerca se vuelven a vincular sin necesidad de intervenci\u00f3n manual. Para manejar los m\u00f3dulos Bluetooth se utilizan los comandos Hayes o AT, de los que puedes encontrar informaci\u00f3n en este enlace y a continuaci\u00f3n damos algunos b\u00e1sicos: AT+VERSION: Versi\u00f3n del Firmware. AT+NAMEXXX: Para establecer el nombre que queremos presentar cuando otro dispositivo nos busque. AT+PINXXXX: permite establecer el n\u00famero de identificaci\u00f3n personal, que se requerir\u00e1 para establecer la vinculaci\u00f3n. AT+BAUDX: Permite fijar la velocidad de comunicaci\u00f3n entre el modulo y la consola seg\u00fan los siguientes pares: 1 -> 1200 bps | -5 -> 19200 bps 2 -> 2400 bps | -6 -> 38400 bps 3 -> 4800 bps | -7 -> 57600 bps 4 -> 9600 bps | -8 -> 115200 bps La velocidad por defecto es la de 9600 bps. Los m\u00f3dulos mas conocidosson el HC-05 y HC-06 que son Bluetooth V2 y cuyo aspecto podemos ver en la imagen siguiente: M\u00f3dulos HC-05 y HC-06 Para poder hacer la comunicaci\u00f3n por Bluetooth con nuestra placa Imagina TdR STEAM tenemos que conectar un m\u00f3dulo Bluetooth en el conector de comunicaciones serie. En nuestro caso utilizaremos un m\u00f3dulo HC-06.","title":"M\u00f3dulo Bluetooth"},{"location":"R14/#en-la-tdr-steam","text":"El puerto de comunicaciones Rx/Tx en la TdR STEAM Es muy importante poner el interruptor en la posici\u00f3n adecuada seg\u00fan queramos funcionar en modo Bluetooth o programar la placa UNO. Recordemos que: Interruptor en posici\u00f3n OFF: para grabar firmware desde ArduinoBlocks. Interruptor en posici\u00f3n ON: modo Bluetooth.","title":"En la TdR STEAM"},{"location":"R14/#programando-el-reto","text":"Vamos a necesitar dos programas para poder trabajar, a saber: Un programa que haga funcionar la placa UNO con la shield TdR STEAM que programaremos desde ArduinoBlocks. Una aplicaci\u00f3n que funcionar\u00e1 en nuestro tel\u00e9fono m\u00f3vil que programaremos con AppInventor2.","title":"Programando el reto"},{"location":"R14/#programa-en-appinventor2","text":"No vamos a entrar en detalles sobre el tema y simplemente expondremos el proceso que seguimos paso a paso. Lo primero que debemos hacer es crear una cuenta, si no la tenemos ya, y loguearnos en MIT App Inventor. Una vez hecho esto procedemos a crear nuestra aplicaci\u00f3n tanto en \"Designer\" como en \"Blocks\". Este es el paso a paso seguido: Paso 1 : Configuramos \"Designer\" para que tenga el aspecto que vemos en la imagen siguiente: Designer en AppInventor Se han colocado un ListPicker, dos botones y un cliente de Bluettoth sobre un nuevo proyecto creado desde la paleta de componentes. El ListPicker se ha renombrado y se ha establecido que su anchura se adapte a su contenedor (Fill parent) y a cada uno de los botones se le ha modificado el texto por defecto para que sea el que se ve en la imagen. El componente BluetoothClient no ser\u00e1 visible en la APP. Paso 2 : Nos cambiamos al modo programaci\u00f3n haciendo clic sobre el bot\u00f3n Blocks en la esquina superior derecha. Vamos localizando y configurando los distintos bloques que vemos en la imagen siguiente, que no es otra cosa que la programaci\u00f3n de nuestra aplicaci\u00f3n para m\u00f3vil. Como observamos el sistema es totalmente similar al de ArduinoBlocks por lo que no debe resultarnos especialmente dif\u00edcil localizar los bloques. Programa por bloques de nuestra APP","title":"Programa en AppInventor2"},{"location":"R14/#programa-en-arduinoblocks","text":"Paso 3 : Creamos el programa siguiente en ArduinoBlocks. El programa en ArduinoBlocks del Reto 14","title":"Programa en ArduinoBlocks"},{"location":"R14/#proceso-de-prueba","text":"Una vez tenemos los dos programas preparados continuamos con el paso a paso. Paso 4 : Cargamos el programa de ArduinoBlocks en la placa UNO. Para ello debemos asegurarnos, si tenemos el m\u00f3dulo Bluetooth colocado, de poner el interruptor en la posici\u00f3n OFF o no podremos programar nuestra placa. Muy probablemente la aplicaci\u00f3n se quedar\u00e1 colgada y no nos dejar\u00e1 hacer nada oblig\u00e1ndonos a reiniciar el equipo. Paso 5 : Instalar la aplicaci\u00f3n en el tel\u00e9fono m\u00f3vil. En mi caso he ido al men\u00fa \"Build\" y he escogido \"Android App (.apk). Tras un proceso que dura unos segundos se nos muestra en pantalla una ventana emergente como la de la imagen siguiente. Podemos escanear el c\u00f3digo QR directamente desde el m\u00f3vil y seguir los pasos de instalaci\u00f3n que se nos muestren o descargar desde el bot\u00f3n \"Download\" y proceder a la instalaci\u00f3n. Opciones de descarga de Android App Paso 6 : Sincronizar el Bluetooth del m\u00f3vil con el m\u00f3dulo Bluetooth de la placa UNO. Para ello Conectamos y Abrimos el servicio Bluetooth del m\u00f3vil y buscamos el nuevo dispositivo. Elegimos el que corresponda a nuestro caso e introducimos la contrase\u00f1a que normalmente ser\u00e1 1234 aunque opcionalmente puede ser 0000. Paso 7 : Abrimos la aplicaci\u00f3n, que en este caso se llama TdR-STEAM. Probar la funcionalidad del bot\u00f3n conectar que inicialmente tendr\u00e1 las letras de color negro, nos saldr\u00e1 el dispositivo con el que estamos emparejados, y las letras del bot\u00f3n \"Conectar\" cambian al color establecido en la programaci\u00f3n y a luz del m\u00f3dulo Bluetooth de la placa Imagina TDR STEAM quedar\u00e1 fija (hasta ahora ha estado parpadeando) en el color rojo. Es MUY IMPORTANTE comprobar que el interruptor ahora est\u00e1 en la posici\u00f3n ON en la placa Imagina TdR STEAM. Si pulsamos sobre el bot\u00f3n LED ON se encender\u00e1 el LED azul y si pulsamos sobre el bot\u00f3n LED OFF se apagar\u00e1. El programa de ArduinoBlocks lo tenemos disponible en Reto-14 y el de App Inventor en App-TdR-STEAM .","title":"Proceso de prueba"},{"location":"R15/","text":"Reto-15. IoT (WiFi) \u00b6 Enunciado \u00b6 En este reto vamos a hablar de como comunicar nuestra placa TdR STEAM con internet y de como enviar datos medidos localmente a la nube, empezando as\u00ed a trabajar el Internet de las Cosas. El objeto no es profundizar en conceptos t\u00e9cnicos como Broker, MQTT, Mosquitto, etc. Vamos a limitarnos a aprender a subir unos datos concretos que no nos har\u00e1n expertos en el tema, pero que ser\u00e1 un primer paso. Teor\u00eda \u00b6 Se recomienda encarecidamente leer el apartado Teor\u00eda b\u00e1sica de IoT de este mismo tutorial En la TdR STEAM \u00b6 MUY IMPORTANTE : recordar que la placa TdR STEAM ya realiza el cruzamiento de conexiones entre Rx y Tx. Tx-Rx en la TdR STEAM Programando el reto \u00b6 Para poder visualizar los datos enviados desde la placa Imagina TdR STEAM utilizaremos el programa ThingSpeak y la aplicaci\u00f3n ThingView. Por tanto, hemos de preparar los siguientes programas: ArduinoBlocks: programa de recogida y env\u00edo de datos. ThingSpeak: programa para ver los datos en el ordenador a trav\u00e9s Internet. ThingView: aplicaci\u00f3n para ver los datos en el tel\u00e9fono m\u00f3vil. Thingspeak \u00b6 Una vez creada la cuenta en ThingSpeak tenemos que apuntar los siguientes datos: Channel ID: referencia de nuestro dispositivo. Author: referencia del autor del dispositivo. Estos datos los tendremos disponibles cuando creemos nuestro primer canal. Perfil de la cuenta creada en Thingspeak Si ahora nos dirigimos al men\u00fa \"Channels\" y escogemos \"My Channels\" entraremos en la p\u00e1gina de creaci\u00f3n de un canal. En la parte superior de la p\u00e1gina es donde ponemos nombre al canal y establecemos los campos que vamos a usar, como ejemplo tenemos el de la imagen siguiente: Parte 1 de la creaci\u00f3n de un canal Si avanzamos hac\u00eda abajo en esta p\u00e1gina podemos seguir cumplimentando datos de nuestro canal, como vemos en la imagen siguiente: Parte 2 de la creaci\u00f3n de un canal Activar la localizaci\u00f3n y poner las coordenadas har\u00e1 que, posteriormente lo veremos, aparezca la localizaci\u00f3n puesta en un mapa. Algo similar sucede con el v\u00eddeo enlazado. Si damos a guardar se nos mostrar\u00e1 una pantalla similar a la siguiente, donde podemos ver los datos del canal Reto-15. Aspecto del canal recien creado Como vemos este canal es privado y solamente se ha creado para mostrar las capturas que aqu\u00ed se est\u00e1n mostrando y por lo tanto no ser\u00e1 un canal accesible en el futuro. En la pesta\u00f1a \u201cAPI Keys\u201d vamos a tener disponibles los datos con los c\u00f3digos identificativos para escribir en el canal y para leer el canal, tal y como vemos en la imagen siguiente. Estos datos los tendremos que usar posteriormente en ArduinoBlocks. API-Keys Con esto finalizamos la configuraci\u00f3n de Thingspeak aunque hay otras muchas cosas que se pueden hacer con el broker. ArduinoBlocks \u00b6 Una vez creado el canal en el broker ya estamos en condiciones de preparar el programa de ArduinoBlocks que env\u00ede los datos del sensor DHT11 a la nube v\u00eda WiFi. Para ello en el bloque \"Inicializar\" tenemos que configurar los diferentes campos seg\u00fan vemos en la imagen siguiente: Configuraci\u00f3n del bloque Inicializar Una vez configurada la conexi\u00f3n vamos a implementar dos funciones una para leer los sensores y otra para subir los datos a la nube. En la imagen siguiente vemos la programaci\u00f3n de la funci\u00f3n leer sensores, que l\u00f3gicamente va a consistir en leer los datos de humedad y temperatura del sensor DHT11 y guardarlos en sendas variables. Funci\u00f3n leer sensor DHT11 El bloque a utilizar lo encontramos en el men\u00fa MQTT de comunicaciones y tiene el aspecto de la imagen siguiente: Bloque para publicar en MQTT En tema debemos colocar el bloque \"publicar\" Thingspeak, que nos llevar\u00eda a tener el siguiente estado de programaci\u00f3n: El bloque publicar de Thingspeak A continuaci\u00f3n, configuraremos la publicaci\u00f3n de los datos con la funci\u00f3n subir datos a la nube y para ello debemos localizar: Channel ID: identificador de nuestro canal en ThingSpeak. Write API Key: contrase\u00f1a de escritura o c\u00f3digo para enviar los datos a ThingSpeak. Estos datos los hemos de poner en cada bloque que pongamos de \"Publicar Tema\" y debemos hacer corresponder el campo Field de ArduinoBlocks con el de Thingspeak. En la imagen siguiente vemos el aspecto de la funci\u00f3n subir-datos. Funci\u00f3n subir datos Lo \u00fanico que resta para finalizar el programa es llamar a las funciones dentro del bucle. El aspecto final del programa lo vemos en la imagen siguiente: Programa del Reto 15 Cuando estamos trabajando con WiFi los bloques \"Esperar\" ya que durante la espera la conexi\u00f3n debe seguir realizando sus tareas y puede llegar el momento en que, si los usamos, la conexi\u00f3n se corte o moience a hacer cosas extra\u00f1as. Por eso es recomendable utilizar el bloque \"Ejecutar cada\" que vemos en la imagen anterior y evitar as\u00ed posibles bloqueos en el micro. Es conveniente leer el apartado \"Tiempo\" ArduinoBlocks - FreeBook as\u00ed como su Anexo I: Bloques incompatibles con bloqueos de tiempo. El bloque \"Ejecutar cada\" se establece a 16 segundos y esto es importante porque la versi\u00f3n gratuita de ThingSpeak s\u00f3lo permite subir datos cada 15 segundos ( ThingSpeak\u2122 Licensing FAQ ) y le damos un segundo mas porque justo los 15 segundos en alguna ocasi\u00f3n me ha generado alg\u00fan problema. \u00a1Ya hemos configurado ArduinoBlocks! La programaci\u00f3n del reto sin configurar los distintos campos est\u00e1 en el programa Reto-15 . Visualizaci\u00f3n de datos \u00b6 Una vez hecho esto ya podemos subir el programa a la placa y al cabo de unos segundos empezaremos a ver los primeros datos subidos en los dos campos del canal de ThingSpeak en la pesta\u00f1a \"Private View\" de la web, tal y como muestra la imagen siguiente: Vista de Private View en la web de Thingspeak Visualizaci\u00f3n de datos en smartphone o similar \u00b6 MATLAB a trav\u00e9s de su servidor (broker) Thingspeak ofrece varias aplicaciones para dispositivos smartphone. En la imagen siguiente vemos el resultado de una b\u00fasqueda en un dispositivo Android en Play Store. Thingspeak en Play Store Nos centraremos en las dos destacadas en la imagen anterior. ThingView Una vez instalada la App en nuestro smartphone podemos a\u00f1adir los canales que deseemos, simplemente haciendo clic sobre el signo m\u00e1s y dando el identificador del canal. En la imagen siguiente observamos el canal del Reto 15 creado para este caso. ThingView con canal agregado En esta otra imagen vemos la visualizaci\u00f3n de datos del canal en ThingView. Visulizando datos en ThingView Actividades de ampliaci\u00f3n \u00b6 R15.A1 : (No solucionada) Estudiar la funcionalidad de las pesta\u00f1as y botones que se ven en la imagen siguiente y probar, realizando una memoria al estilo de los retos de este tutorial, al menos sobre los tres destacados. Actividad 1 del reto 15 R15.A2 : (No solucionada) Instalar la aplicaci\u00f3n ThingView y realizar la visualizaci\u00f3n de datos de al menos un canal creado para esta actividad. R15.A3:Widget : (No solucionada) La segunda opci\u00f3n de descarga es una microaplicaci\u00f3n widget para la pantalla de nuestro m\u00f3vil que nos va a permitir estar viendo dos de las variables que tengamos en nuestro canal. En este caso, adem\u00e1s del n\u00famero de canal debemos conocer la API key de lectura. El widget permite establecer alarmas cuando se superan, por encima o por abajo, los valores de la variable establecidos. A\u00f1adir el widget al smartphone y experimentar sus diferentes opciones.","title":"Reto-15. IoT (WiFi)"},{"location":"R15/#reto-15-iot-wifi","text":"","title":"Reto-15. IoT (WiFi)"},{"location":"R15/#enunciado","text":"En este reto vamos a hablar de como comunicar nuestra placa TdR STEAM con internet y de como enviar datos medidos localmente a la nube, empezando as\u00ed a trabajar el Internet de las Cosas. El objeto no es profundizar en conceptos t\u00e9cnicos como Broker, MQTT, Mosquitto, etc. Vamos a limitarnos a aprender a subir unos datos concretos que no nos har\u00e1n expertos en el tema, pero que ser\u00e1 un primer paso.","title":"Enunciado"},{"location":"R15/#teoria","text":"Se recomienda encarecidamente leer el apartado Teor\u00eda b\u00e1sica de IoT de este mismo tutorial","title":"Teor\u00eda"},{"location":"R15/#en-la-tdr-steam","text":"MUY IMPORTANTE : recordar que la placa TdR STEAM ya realiza el cruzamiento de conexiones entre Rx y Tx. Tx-Rx en la TdR STEAM","title":"En la TdR STEAM"},{"location":"R15/#programando-el-reto","text":"Para poder visualizar los datos enviados desde la placa Imagina TdR STEAM utilizaremos el programa ThingSpeak y la aplicaci\u00f3n ThingView. Por tanto, hemos de preparar los siguientes programas: ArduinoBlocks: programa de recogida y env\u00edo de datos. ThingSpeak: programa para ver los datos en el ordenador a trav\u00e9s Internet. ThingView: aplicaci\u00f3n para ver los datos en el tel\u00e9fono m\u00f3vil.","title":"Programando el reto"},{"location":"R15/#thingspeak","text":"Una vez creada la cuenta en ThingSpeak tenemos que apuntar los siguientes datos: Channel ID: referencia de nuestro dispositivo. Author: referencia del autor del dispositivo. Estos datos los tendremos disponibles cuando creemos nuestro primer canal. Perfil de la cuenta creada en Thingspeak Si ahora nos dirigimos al men\u00fa \"Channels\" y escogemos \"My Channels\" entraremos en la p\u00e1gina de creaci\u00f3n de un canal. En la parte superior de la p\u00e1gina es donde ponemos nombre al canal y establecemos los campos que vamos a usar, como ejemplo tenemos el de la imagen siguiente: Parte 1 de la creaci\u00f3n de un canal Si avanzamos hac\u00eda abajo en esta p\u00e1gina podemos seguir cumplimentando datos de nuestro canal, como vemos en la imagen siguiente: Parte 2 de la creaci\u00f3n de un canal Activar la localizaci\u00f3n y poner las coordenadas har\u00e1 que, posteriormente lo veremos, aparezca la localizaci\u00f3n puesta en un mapa. Algo similar sucede con el v\u00eddeo enlazado. Si damos a guardar se nos mostrar\u00e1 una pantalla similar a la siguiente, donde podemos ver los datos del canal Reto-15. Aspecto del canal recien creado Como vemos este canal es privado y solamente se ha creado para mostrar las capturas que aqu\u00ed se est\u00e1n mostrando y por lo tanto no ser\u00e1 un canal accesible en el futuro. En la pesta\u00f1a \u201cAPI Keys\u201d vamos a tener disponibles los datos con los c\u00f3digos identificativos para escribir en el canal y para leer el canal, tal y como vemos en la imagen siguiente. Estos datos los tendremos que usar posteriormente en ArduinoBlocks. API-Keys Con esto finalizamos la configuraci\u00f3n de Thingspeak aunque hay otras muchas cosas que se pueden hacer con el broker.","title":"Thingspeak"},{"location":"R15/#arduinoblocks","text":"Una vez creado el canal en el broker ya estamos en condiciones de preparar el programa de ArduinoBlocks que env\u00ede los datos del sensor DHT11 a la nube v\u00eda WiFi. Para ello en el bloque \"Inicializar\" tenemos que configurar los diferentes campos seg\u00fan vemos en la imagen siguiente: Configuraci\u00f3n del bloque Inicializar Una vez configurada la conexi\u00f3n vamos a implementar dos funciones una para leer los sensores y otra para subir los datos a la nube. En la imagen siguiente vemos la programaci\u00f3n de la funci\u00f3n leer sensores, que l\u00f3gicamente va a consistir en leer los datos de humedad y temperatura del sensor DHT11 y guardarlos en sendas variables. Funci\u00f3n leer sensor DHT11 El bloque a utilizar lo encontramos en el men\u00fa MQTT de comunicaciones y tiene el aspecto de la imagen siguiente: Bloque para publicar en MQTT En tema debemos colocar el bloque \"publicar\" Thingspeak, que nos llevar\u00eda a tener el siguiente estado de programaci\u00f3n: El bloque publicar de Thingspeak A continuaci\u00f3n, configuraremos la publicaci\u00f3n de los datos con la funci\u00f3n subir datos a la nube y para ello debemos localizar: Channel ID: identificador de nuestro canal en ThingSpeak. Write API Key: contrase\u00f1a de escritura o c\u00f3digo para enviar los datos a ThingSpeak. Estos datos los hemos de poner en cada bloque que pongamos de \"Publicar Tema\" y debemos hacer corresponder el campo Field de ArduinoBlocks con el de Thingspeak. En la imagen siguiente vemos el aspecto de la funci\u00f3n subir-datos. Funci\u00f3n subir datos Lo \u00fanico que resta para finalizar el programa es llamar a las funciones dentro del bucle. El aspecto final del programa lo vemos en la imagen siguiente: Programa del Reto 15 Cuando estamos trabajando con WiFi los bloques \"Esperar\" ya que durante la espera la conexi\u00f3n debe seguir realizando sus tareas y puede llegar el momento en que, si los usamos, la conexi\u00f3n se corte o moience a hacer cosas extra\u00f1as. Por eso es recomendable utilizar el bloque \"Ejecutar cada\" que vemos en la imagen anterior y evitar as\u00ed posibles bloqueos en el micro. Es conveniente leer el apartado \"Tiempo\" ArduinoBlocks - FreeBook as\u00ed como su Anexo I: Bloques incompatibles con bloqueos de tiempo. El bloque \"Ejecutar cada\" se establece a 16 segundos y esto es importante porque la versi\u00f3n gratuita de ThingSpeak s\u00f3lo permite subir datos cada 15 segundos ( ThingSpeak\u2122 Licensing FAQ ) y le damos un segundo mas porque justo los 15 segundos en alguna ocasi\u00f3n me ha generado alg\u00fan problema. \u00a1Ya hemos configurado ArduinoBlocks! La programaci\u00f3n del reto sin configurar los distintos campos est\u00e1 en el programa Reto-15 .","title":"ArduinoBlocks"},{"location":"R15/#visualizacion-de-datos","text":"Una vez hecho esto ya podemos subir el programa a la placa y al cabo de unos segundos empezaremos a ver los primeros datos subidos en los dos campos del canal de ThingSpeak en la pesta\u00f1a \"Private View\" de la web, tal y como muestra la imagen siguiente: Vista de Private View en la web de Thingspeak","title":"Visualizaci\u00f3n de datos"},{"location":"R15/#visualizacion-de-datos-en-smartphone-o-similar","text":"MATLAB a trav\u00e9s de su servidor (broker) Thingspeak ofrece varias aplicaciones para dispositivos smartphone. En la imagen siguiente vemos el resultado de una b\u00fasqueda en un dispositivo Android en Play Store. Thingspeak en Play Store Nos centraremos en las dos destacadas en la imagen anterior. ThingView Una vez instalada la App en nuestro smartphone podemos a\u00f1adir los canales que deseemos, simplemente haciendo clic sobre el signo m\u00e1s y dando el identificador del canal. En la imagen siguiente observamos el canal del Reto 15 creado para este caso. ThingView con canal agregado En esta otra imagen vemos la visualizaci\u00f3n de datos del canal en ThingView. Visulizando datos en ThingView","title":"Visualizaci\u00f3n de datos en smartphone o similar"},{"location":"R15/#actividades-de-ampliacion","text":"R15.A1 : (No solucionada) Estudiar la funcionalidad de las pesta\u00f1as y botones que se ven en la imagen siguiente y probar, realizando una memoria al estilo de los retos de este tutorial, al menos sobre los tres destacados. Actividad 1 del reto 15 R15.A2 : (No solucionada) Instalar la aplicaci\u00f3n ThingView y realizar la visualizaci\u00f3n de datos de al menos un canal creado para esta actividad. R15.A3:Widget : (No solucionada) La segunda opci\u00f3n de descarga es una microaplicaci\u00f3n widget para la pantalla de nuestro m\u00f3vil que nos va a permitir estar viendo dos de las variables que tengamos en nuestro canal. En este caso, adem\u00e1s del n\u00famero de canal debemos conocer la API key de lectura. El widget permite establecer alarmas cuando se superan, por encima o por abajo, los valores de la variable establecidos. A\u00f1adir el widget al smartphone y experimentar sus diferentes opciones.","title":"Actividades de ampliaci\u00f3n"},{"location":"hard/","text":"Hardware TdR STEAM \u00b6 La tabla siguiente es una descripci\u00f3n del hardware TdR-STEAM. Imagen N Sensor, actuador o dispositivo externo Pin de conexi\u00f3n 1 Interface I2C o IIC SDA-A4 y SCL-A5 2 Pulsadores SW1 y SW2 D2 y D7 3 Diodos LED Azul (LED3) y Rojo (LED4) D13 y D12 4 Led RGB o neopixel D6, D9 y D10 5 Dos conectores para Entradas/Salidas digitales D3 y D5 6 Conector de comunicaciones Bluetooth y WiFi (Swich On/Off) Rx y Tx 7 Sensor de Temperatura y Humedad DHT11 D4 8 Potenci\u00f3metro giratorio de 270\u00ba A0 9 Zumbador Piezoel\u00e9ctrico o buzzer D8 10 Diodo receptor de infrarrojos (IR) D11 11 Sensor de luminosidad (LDR) A1 12 Bot\u00f3n de Reset -- 13 Conector para entrada anal\u00f3gica A3 14 Sensor de temperatura (LM35) A2 En la tabla siguiente se establece la relaci\u00f3n entre los elementos de la placa TdR STEAM y las conexiones de una placa UNO. Pin UNO Uso en TdR STEAM Descripci\u00f3n D0 Rx Pin de recepci\u00f3n Bluetooth y WiFi D1 Tx Pin de transmisi\u00f3n Bluetooth y WiFi D2 Pulsador SW1 Entrada digital D3 Conector para entrada/salida digital externa Entrada/salida digital D4 Sensor de Temperatura y Humedad DHT11 Entrada digital D5 Conector para entrada/salida digital externa Entrada/salida digital D6 Color rojo del LED RGB Salida digital D7 Pulsador SW2 Entrada digital D8 Zumbador o buzzer Salida digital D9 Color verde del LED RGB Salida digital D10 Color azul del LED RGB Salida digital D11 Sensor IR Entrada digital D12 LED rojo Salida digital D13 LED azul Salida digital A0 Potenci\u00f3metro Entrada anal\u00f3gica A1 Sensor de luz (LDR) Entrada anal\u00f3gica A2 Sensor de temperatura (LM35) Entrada anal\u00f3gica A3 Conector para entrada anal\u00f3gica externa Entrada anal\u00f3gica A4 SDA (Serial DAta.) Datos I2C A5 SCL (Serial CLock) Se\u00f1al de reloj I2C","title":"Hardware TdR STEAM"},{"location":"hard/#hardware-tdr-steam","text":"La tabla siguiente es una descripci\u00f3n del hardware TdR-STEAM. Imagen N Sensor, actuador o dispositivo externo Pin de conexi\u00f3n 1 Interface I2C o IIC SDA-A4 y SCL-A5 2 Pulsadores SW1 y SW2 D2 y D7 3 Diodos LED Azul (LED3) y Rojo (LED4) D13 y D12 4 Led RGB o neopixel D6, D9 y D10 5 Dos conectores para Entradas/Salidas digitales D3 y D5 6 Conector de comunicaciones Bluetooth y WiFi (Swich On/Off) Rx y Tx 7 Sensor de Temperatura y Humedad DHT11 D4 8 Potenci\u00f3metro giratorio de 270\u00ba A0 9 Zumbador Piezoel\u00e9ctrico o buzzer D8 10 Diodo receptor de infrarrojos (IR) D11 11 Sensor de luminosidad (LDR) A1 12 Bot\u00f3n de Reset -- 13 Conector para entrada anal\u00f3gica A3 14 Sensor de temperatura (LM35) A2 En la tabla siguiente se establece la relaci\u00f3n entre los elementos de la placa TdR STEAM y las conexiones de una placa UNO. Pin UNO Uso en TdR STEAM Descripci\u00f3n D0 Rx Pin de recepci\u00f3n Bluetooth y WiFi D1 Tx Pin de transmisi\u00f3n Bluetooth y WiFi D2 Pulsador SW1 Entrada digital D3 Conector para entrada/salida digital externa Entrada/salida digital D4 Sensor de Temperatura y Humedad DHT11 Entrada digital D5 Conector para entrada/salida digital externa Entrada/salida digital D6 Color rojo del LED RGB Salida digital D7 Pulsador SW2 Entrada digital D8 Zumbador o buzzer Salida digital D9 Color verde del LED RGB Salida digital D10 Color azul del LED RGB Salida digital D11 Sensor IR Entrada digital D12 LED rojo Salida digital D13 LED azul Salida digital A0 Potenci\u00f3metro Entrada anal\u00f3gica A1 Sensor de luz (LDR) Entrada anal\u00f3gica A2 Sensor de temperatura (LM35) Entrada anal\u00f3gica A3 Conector para entrada anal\u00f3gica externa Entrada anal\u00f3gica A4 SDA (Serial DAta.) Datos I2C A5 SCL (Serial CLock) Se\u00f1al de reloj I2C","title":"Hardware TdR STEAM"},{"location":"operadores/","text":"Operadores en programaci\u00f3n C++ \u00b6 \u00bfQue es un operador? \u00b6 En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos. Operadores de asignaci\u00f3n \u00b6 Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a Operadores Aritm\u00e9ticos \u00b6 Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1 Operadores Relacionales o de comparaci\u00f3n \u00b6 Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b Operadores l\u00f3gicos \u00b6 Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores en programaci\u00f3n C++"},{"location":"operadores/#operadores-en-programacion-c","text":"","title":"Operadores en programaci\u00f3n C++"},{"location":"operadores/#que-es-un-operador","text":"En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos.","title":"\u00bfQue es un operador?"},{"location":"operadores/#operadores-de-asignacion","text":"Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a","title":"Operadores de asignaci\u00f3n"},{"location":"operadores/#operadores-aritmeticos","text":"Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1","title":"Operadores Aritm\u00e9ticos"},{"location":"operadores/#operadores-relacionales-o-de-comparacion","text":"Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b","title":"Operadores Relacionales o de comparaci\u00f3n"},{"location":"operadores/#operadores-logicos","text":"Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores l\u00f3gicos"},{"location":"retos/","text":"Retos \u00b6 En el apartado de retos y actividades primero se ha visto una explicaci\u00f3n breve del componente electr\u00f3nico que se va a utilizar y, a continuaci\u00f3n, una descripci\u00f3n de la pr\u00e1ctica o pr\u00e1cticas a realizar. Finalmente se hace una propuesta de ejercicio de ampliaci\u00f3n. A continuaci\u00f3n se da un listado de los retos propuestos, conteniendo cada uno de ellos un enlace a un archivo comprimido con los programas de ese reto. Reto-01. LED Reto-02. LEDs rojo y azul Reto-03. LED RGB Reto-04. Zumbador Reto-05. Pulsadores Reto-06. Potenci\u00f3metro Reto-07. Fotorresistencia LDR Reto-08. Sensor de temperatura LM35 Reto-09. Sensor de temperatura y humedad DHT-11 Reto-10. Emisor y receptor de infrarrojos (IR) Reto-11. Puerto de expansi\u00f3n I2C. La LCD de 2x16 Reto-12. Sensor de sonido o micr\u00f3fono Reto-13. Termohigr\u00f3metro Reto-14. Bluetooth Reto-15. IoT . En programa del enlace est\u00e1 sin configurar en sus distintos campos.","title":"Todos los programas de los retos"},{"location":"retos/#retos","text":"En el apartado de retos y actividades primero se ha visto una explicaci\u00f3n breve del componente electr\u00f3nico que se va a utilizar y, a continuaci\u00f3n, una descripci\u00f3n de la pr\u00e1ctica o pr\u00e1cticas a realizar. Finalmente se hace una propuesta de ejercicio de ampliaci\u00f3n. A continuaci\u00f3n se da un listado de los retos propuestos, conteniendo cada uno de ellos un enlace a un archivo comprimido con los programas de ese reto. Reto-01. LED Reto-02. LEDs rojo y azul Reto-03. LED RGB Reto-04. Zumbador Reto-05. Pulsadores Reto-06. Potenci\u00f3metro Reto-07. Fotorresistencia LDR Reto-08. Sensor de temperatura LM35 Reto-09. Sensor de temperatura y humedad DHT-11 Reto-10. Emisor y receptor de infrarrojos (IR) Reto-11. Puerto de expansi\u00f3n I2C. La LCD de 2x16 Reto-12. Sensor de sonido o micr\u00f3fono Reto-13. Termohigr\u00f3metro Reto-14. Bluetooth Reto-15. IoT . En programa del enlace est\u00e1 sin configurar en sus distintos campos.","title":"Retos"},{"location":"soft/","text":"Software \u00b6 Vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"Software"},{"location":"soft/#software","text":"Vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"Software"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP ArduinoBlocks ArduinoBlocks Connector","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP ArduinoBlocks ArduinoBlocks Connector","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 ArduinoBlocks - FreeBook (online & updated) Wikipedia Retos con Imagina TdR STEAM Manual Actividades Imagina TdR STEAM wiki de keyestudio . En ellas buscamos la informaci\u00f3n de cada elemento keyestudio.","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"ArduinoBlocks - FreeBook (online & updated) Wikipedia Retos con Imagina TdR STEAM Manual Actividades Imagina TdR STEAM wiki de keyestudio . En ellas buscamos la informaci\u00f3n de cada elemento keyestudio.","title":"Webgraf\u00eda y bibliograf\u00eda"}]}