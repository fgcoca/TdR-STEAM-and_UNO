{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Retos con TdR STEAM y UNO \u00b6 Lo que vamos a necesitar \u00b6 Software \u00b6 Para llevar a cabo la programaci\u00f3n de los retos es necesario estar registrado en ArduinoBlocks y se recomienda hacerlo con el nombre real para posteriormente facilitar la localizaci\u00f3n si es necesaria. La tarea es sencilla y est\u00e1 perfectamente descrita en el Free Book (online & updated) que podemos encontrar en los recursos de la plataforma www.arduinoblocks.com . Creamos un \"nuevo usuario\" utilizando para ello una cuenta de correo v\u00e1lida donde vamos a recibir un correo de confirmaci\u00f3n para activarla. Ya estamos en condiciones de crear nuestros propios proyectos en la plataforma como veremos mas adelante. Crear un nuevo proyecto Descarga e instala en tu ordenador y para tu sistema operativo ArduinoBlocks - Connector . Este programa vamos a necesitarlo para poder comunicar nuestra placa con la plataforma a trav\u00e9s del puerto USB de nuestro ordenador. Hardware imprescindible \u00b6 Una placa Imagina TdR STEAM versi\u00f3n 2.0 como la de la imagen siguiente: Shield TdR-STEAM V2.0 Una placa tipo Arduino UNO R3, o bien alguna de las desarrolladas por ser hardware libre como estas de Keyestudio . Ks0341 - Placa avanzada Keyestudio UNO Compatible Ks0172 - Placa Keyestudio UNO con conectores de 3 pines Hardware recomendado \u00b6 A continuaci\u00f3n exponemos el material adicional que vamos a emplear en esta colecci\u00f3n de retos que no es otro que el incluido en el Kit Imagina TdR STEAM comercializado por la empresa INNOVA DIDACTIC . Mando de control remoto por infrarojos para utilizar en conjunto con el sensor de infrarojos integrado en la placa TdR-STEAM. Mando a distancia por IR Pantalla LCD 1602 IIC (I2C) de 2 l\u00ednea de 16 caracteres. Nos va a permitir mostrar mensajes de texto e ir\u00e1 conectada al conector I2C de la placa TdR-STEAM. LCD 1602 I2C Sensor de sonido anal\u00f3gico (con potenciometro). Se utiliza b\u00e1sicamente para detectar el nivel sonoro ambiental. El potenciometro permite ajustar el nivel de ganancia. Sensor de sonido anal\u00f3gico","title":"Introducci\u00f3n"},{"location":"#retos-con-tdr-steam-y-uno","text":"","title":"Retos con TdR STEAM y UNO"},{"location":"#lo-que-vamos-a-necesitar","text":"","title":"Lo que vamos a necesitar"},{"location":"#software","text":"Para llevar a cabo la programaci\u00f3n de los retos es necesario estar registrado en ArduinoBlocks y se recomienda hacerlo con el nombre real para posteriormente facilitar la localizaci\u00f3n si es necesaria. La tarea es sencilla y est\u00e1 perfectamente descrita en el Free Book (online & updated) que podemos encontrar en los recursos de la plataforma www.arduinoblocks.com . Creamos un \"nuevo usuario\" utilizando para ello una cuenta de correo v\u00e1lida donde vamos a recibir un correo de confirmaci\u00f3n para activarla. Ya estamos en condiciones de crear nuestros propios proyectos en la plataforma como veremos mas adelante. Crear un nuevo proyecto Descarga e instala en tu ordenador y para tu sistema operativo ArduinoBlocks - Connector . Este programa vamos a necesitarlo para poder comunicar nuestra placa con la plataforma a trav\u00e9s del puerto USB de nuestro ordenador.","title":"Software"},{"location":"#hardware-imprescindible","text":"Una placa Imagina TdR STEAM versi\u00f3n 2.0 como la de la imagen siguiente: Shield TdR-STEAM V2.0 Una placa tipo Arduino UNO R3, o bien alguna de las desarrolladas por ser hardware libre como estas de Keyestudio . Ks0341 - Placa avanzada Keyestudio UNO Compatible Ks0172 - Placa Keyestudio UNO con conectores de 3 pines","title":"Hardware imprescindible"},{"location":"#hardware-recomendado","text":"A continuaci\u00f3n exponemos el material adicional que vamos a emplear en esta colecci\u00f3n de retos que no es otro que el incluido en el Kit Imagina TdR STEAM comercializado por la empresa INNOVA DIDACTIC . Mando de control remoto por infrarojos para utilizar en conjunto con el sensor de infrarojos integrado en la placa TdR-STEAM. Mando a distancia por IR Pantalla LCD 1602 IIC (I2C) de 2 l\u00ednea de 16 caracteres. Nos va a permitir mostrar mensajes de texto e ir\u00e1 conectada al conector I2C de la placa TdR-STEAM. LCD 1602 I2C Sensor de sonido anal\u00f3gico (con potenciometro). Se utiliza b\u00e1sicamente para detectar el nivel sonoro ambiental. El potenciometro permite ajustar el nivel de ganancia. Sensor de sonido anal\u00f3gico","title":"Hardware recomendado"},{"location":"3D/","text":"Caja contenedor imprimible 3D \u00b6 Partes \u00b6 La caja est\u00e1 compuesta de una base, una tapa, tres tornillos y un destornillador. La base con indicaci\u00f3n de donde va a ir cada elemento la vemos en la imagen siguiente: Base o caja El aspecto de la tapa lo tenemos en la imagen siguiente, donde podemos observar el orificio estriado que servir\u00e1 para colocar el destornillador cuando finalicemos el montaje. Tapa Finalmente en la imagen siguiente podemos ver el aspecto de uno de los tres tornillos que sujetan la tapa a la caja y el del destornillador. Tornillo y destornillador Archivos stl listos para descargar e imprimir \u00b6 Archivo STL de la caja: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip Pasos de montaje \u00b6 Paso 1 . Colocamos la TdR STEAM sobre la placa UNO pasando el cable de cuatro hilos entre ambas y colocando el conector JST de 4 pines en la TdR STEAM (este conector solamente entra en una posici\u00f3n) para obtener algo similar a la imagen siguiente: Montaje de la TdR STEAM sobre UNO conectando el I2C Paso 2 . Conectamos la LCD mediante el conector plano de 4 pines asegurando que el cable negro va al pin marcado como GND. Hay que tener precauci\u00f3n con la orientaci\u00f3n de este conector pues es reversible. El resultado debe ser similar al siguiente: Montaje de la LCD Paso 3 . En la imagen siguiente se ven los elementos anteriores colocados en su lugar. Montaje de Shield+UNO y LCD en la base Paso 4 . Conectamos un cable de tres hilos al micr\u00f3fono teniendo en cuenta que el cable negro va al terminal marcado con una G y el otro extremo del cable lo colocamos en el conector JST de 3 pines marcado con A3. Pasamos los cables por debajo de la LCD y el resultado ser\u00e1 algo similar a lo siguiente: Montaje de micr\u00f3fono Paso 5 . Colocamos el teclado en su lugar. Colocaci\u00f3n del mando a distancia Paso 6 . Finalmente colocamos la tapa y atornillamos cada tornillo en su tuerca, los apretamos con ayuda del destornillador y colocamos este en su alojamiento. Tendremos finalizada la colocaci\u00f3n de elementos en la caja, tal y como vemos a continuaci\u00f3n: Montaje finalizado","title":"Elementos impresi\u00f3n 3D"},{"location":"3D/#caja-contenedor-imprimible-3d","text":"","title":"Caja contenedor imprimible 3D"},{"location":"3D/#partes","text":"La caja est\u00e1 compuesta de una base, una tapa, tres tornillos y un destornillador. La base con indicaci\u00f3n de donde va a ir cada elemento la vemos en la imagen siguiente: Base o caja El aspecto de la tapa lo tenemos en la imagen siguiente, donde podemos observar el orificio estriado que servir\u00e1 para colocar el destornillador cuando finalicemos el montaje. Tapa Finalmente en la imagen siguiente podemos ver el aspecto de uno de los tres tornillos que sujetan la tapa a la caja y el del destornillador. Tornillo y destornillador","title":"Partes"},{"location":"3D/#archivos-stl-listos-para-descargar-e-imprimir","text":"Archivo STL de la caja: caja.stl Archivo STL de la tapa: tapa.stl Archivo STL del tornillo: tornillo.stl Archivo STL del destornillador: destornillador.stl Todos los archivos en un zip: caja-TdR-STEAM.zip","title":"Archivos stl listos para descargar e imprimir"},{"location":"3D/#pasos-de-montaje","text":"Paso 1 . Colocamos la TdR STEAM sobre la placa UNO pasando el cable de cuatro hilos entre ambas y colocando el conector JST de 4 pines en la TdR STEAM (este conector solamente entra en una posici\u00f3n) para obtener algo similar a la imagen siguiente: Montaje de la TdR STEAM sobre UNO conectando el I2C Paso 2 . Conectamos la LCD mediante el conector plano de 4 pines asegurando que el cable negro va al pin marcado como GND. Hay que tener precauci\u00f3n con la orientaci\u00f3n de este conector pues es reversible. El resultado debe ser similar al siguiente: Montaje de la LCD Paso 3 . En la imagen siguiente se ven los elementos anteriores colocados en su lugar. Montaje de Shield+UNO y LCD en la base Paso 4 . Conectamos un cable de tres hilos al micr\u00f3fono teniendo en cuenta que el cable negro va al terminal marcado con una G y el otro extremo del cable lo colocamos en el conector JST de 3 pines marcado con A3. Pasamos los cables por debajo de la LCD y el resultado ser\u00e1 algo similar a lo siguiente: Montaje de micr\u00f3fono Paso 5 . Colocamos el teclado en su lugar. Colocaci\u00f3n del mando a distancia Paso 6 . Finalmente colocamos la tapa y atornillamos cada tornillo en su tuerca, los apretamos con ayuda del destornillador y colocamos este en su alojamiento. Tendremos finalizada la colocaci\u00f3n de elementos en la caja, tal y como vemos a continuaci\u00f3n: Montaje finalizado","title":"Pasos de montaje"},{"location":"IoT_basico/","text":"Teor\u00eda b\u00e1sica de IoT \u00b6 1.- \u00bfQu\u00e9 es la Internet de las Cosas? \u00b6 La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000 2.- M\u00f3dulo ESP8266 ESP-01 \u00b6 Introducci\u00f3n \u00b6 El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C. Programaci\u00f3n \u00b6 El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar. 3.- Comando AT en el ESP8266 \u00b6 El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT 4.- Preparaci\u00f3n del m\u00f3dulo ESP-01 \u00b6 Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 . 5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT \u00b6 Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concreto o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida. 6.- Creaci\u00f3n de un canal en un servidor MQTT \u00b6 En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak 7.- Filtrado por MAC \u00b6 Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#teoria-basica-de-iot","text":"","title":"Teor\u00eda b\u00e1sica de IoT"},{"location":"IoT_basico/#1-que-es-la-internet-de-las-cosas","text":"La expresi\u00f3n \u201cInternet de las cosas\u201d o IoT (del ingl\u00e9s, Internet of Things), internet de todas las cosas o internet en las cosas, hace referencia al uso que hacen de Internet los dispositivos conectados (las cosas) para comunicarse sin intervenci\u00f3n humana directa. Tambi\u00e9n se usa el t\u00e9rmino IoT para referirse al conjunto de estos dispositivos conectados comunicando \u201centre m\u00e1quinas\u201d (M2M) sin requerir interacci\u00f3n humana. No existe una Internet especial o diferente para \u201clas cosas\u201d, en principio, se opera con las mismas redes que en otros usos de Internet. En la imagen siguiente se grafica la conexi\u00f3n de elementos con la nube a trav\u00e9s de la red. Conexi\u00f3n de elementos IoT con la nube El IoT sirve para monitorizaci\u00f3n y control electr\u00f3nico y toma de decisiones inteligente. Es decir, conectar dispositivos a Internet permite enviar y recibir informaci\u00f3n usando una infraestructura global y as\u00ed poder monitorizar y/o controlar autom\u00e1ticamente y a distancia multitud de contextos. Por ejemplo, en entornos urbanos (ciudades inteligentes) se puede conocer la actividad humana, del medio ambiente, del tr\u00e1fico\u2026 tanto para informar de su estado (como las plazas de aparcamiento disponibles, la densidad o velocidad de la circulaci\u00f3n, la contaminaci\u00f3n\u2026) como para tomar decisiones de forma manual o autom\u00e1tica para optimizar los recursos disponibles (iluminaci\u00f3n, riego de jardines, funcionamiento de los sem\u00e1foros\u2026) Para conectar a la red las placas Arduino, sus clones o basadas en el mismo usaremos los m\u00f3dulos ESP8266. El ESP8266 es un chip de bajo costo Wi-Fi que contiene su propio microcontrolador, un Tensilica L106 de 32-bit. Es un chip de bajo bajo coste y reducido tama\u00f1o. El chip ESP8266 forma parte de multitud de m\u00f3dulos comerciales a trav\u00e9s de diferentes soluciones con distintas funciones, pines, tama\u00f1os y precios. Modelos ESP El m\u00e1s simple es el ESP-01, que solo dispone de 2 puertos digitales y necesita un adaptador USB para poder ser programado y es el que vamos a usar aqu\u00ed. Hay otros muchos sistemas como por ejemplo la placa ESP32 STEAMakers de Keyestudio, ESP-12E de ESP8266, la placa de desarrollo NodeMCU, tambi\u00e9n basada en el ESP-12E, Adem\u00e1s, hay placas con WiFi que usan otros chip WiFi diferentes, como la Arduino MKR1000. ESP32 STEAMakers ESP-12E NodeMCU de Keyestudio Arduino MKR1000","title":"1.- \u00bfQu\u00e9 es la Internet de las Cosas?"},{"location":"IoT_basico/#2-modulo-esp8266-esp-01","text":"","title":"2.- M\u00f3dulo ESP8266 ESP-01"},{"location":"IoT_basico/#introduccion","text":"El m\u00f3dulo WiFi ESP-01 es uno de las m\u00e1s populares y econ\u00f3micos, pese a no ser el m\u00e1s potente ni vers\u00e1til. Actualmente, otros modelos como la ESP-12 o el el ESP32 se est\u00e1n integrando en la mayor\u00eda de placas de desarrollo, cobrando un peso e importancia mucho mayor. Sin embargo, nosotros vamos a asociar nuestro peque\u00f1o ESP-01 a una placa UNO, con el \u00fanico fin de darle conectividad WiFi. El ESP-01 trae instalado una versi\u00f3n de firmware con la que podemos comunicarnos con el ESP8266 mediante comandos AT (veremos a continuaci\u00f3n algunos de ellos) a trav\u00e9s del puerto serie. Este tipo de comunicaci\u00f3n nos va a permitir crear un puente entre la placa TdR STEAM y el ESP8266, consiguiendo as\u00ed conectar a una red WiFi y dar un primer paso de gigantes en el mundo IoT. Veamos el aspecto del ESP-01 y algunas de sus caracter\u00edsticas: Imagen ESP-01 Descripci\u00f3n - ESP8266 es el microcontrolador del m\u00f3dulo ESP-01. - La memoria flash es la BG25Q80A - Los LEDs informan de si est\u00e1 encendido o no y de la transmisi\u00f3n de datos (Tx y Rx). - La antena WiFi para la conexi\u00f3n a una internet. - Los pines permiten conectar alimentaci\u00f3n, sensores, \u2026 Toda la informaci\u00f3n en el datasheet del fabricante Los pines est\u00e1n distribuidos de la siguiente forma: Pines ESP-01 Descripci\u00f3n 1 - GND 2 - Pin digital n\u00famero 2 3 - Pin digital n\u00famero 0 4 - RXD es el pin por donde se van a recibir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO3 5 - TXD es el pin por donde se van a transmitir los datos del puerto serie. Trabaja a 3,3 V. Tambi\u00e9n puede ser el pin digital GPIO1 6 - CH_PD es el pin para apagar y encender el ESP-01: si lo ponemos a 0 V (LOW) se apaga, y a 3,3 V (HIGH) se enciende. 7 - RESET pin a 0V resetea el ESP-01 - Vcc es el pin de alimentaci\u00f3n. Funciona a 3,3V y admite un m\u00e1ximo de 3,6 V. La corriente suministrada debe ser mayor que 200 mA. GPIO (del ingl\u00e9s, General Purpose Input Output) son entradas o salidas de prop\u00f3sito general, o sea pines digitales. El ESP-01 soporta comunicaci\u00f3n I2C, por lo que, pese a tener solo un par de GPIOs, podemos conectarle multitud de sensores y actuadores a trav\u00e9s del mencionado bus de datos I2C.","title":"Introducci\u00f3n"},{"location":"IoT_basico/#programacion","text":"El ESP-01 dispone de un microcontrolador y una memoria donde poder almacenar programas, luego es un dispositivo programable en si mismo. Cargar programas en el dispositivo es algo mas complejo de lo que hemos visto hasta ahora dado que tiene dos modos de operaci\u00f3n, el modo flash o de ejecuci\u00f3n y el modo UART o de grabaci\u00f3n y debemos ser nosotros quienes activemos un modo u otro, cosa que hasta ahora el entorno ArduinoBlocks ha sido el encargado de hacerlo. Los modos de operaci\u00f3n se configuran a trav\u00e9s de los puertos GPIO0 y GPIO2. Para programar el ESP-01 hay que usar los pines Rx y Tx para transmitir los datos a la memoria Flash, donde se almacenar\u00e1 el sketch o programa. En las placas de control los pines Rx y Tx est\u00e1n en los pines D0 y D1 respectivamente y tambi\u00e9n son los que se utilizan para cargar programas a una velocidad de 115200 baudios, as\u00ed que si estos pines los ocupamos con el ESP8266 no podremos cargar programas en nuestra placa. Ahora bien, es posible utilizar otros pines para usar WiFi y evitar este problema, pero el resto de pines digitales solamente trabajan a 9600 baudios y el ESP-01 por defecto viene a 115200, luego para utilizarlo en pines distintos a los D0 y D1 de la placa tendremos que reprogramarlo para que la velocidad sea de 9600 baudios. Aunque sea bastante t\u00e9cnico debemos exponer c\u00f3mo configurar los dos modos de funcionamiento de forma breve. Modo de funcionamiento UART . Para cargar un programa en el ESP-01 debemos o bien encenderlo o bien resetearlo pero teniendo los siguientes estados de pines:GPIO0 = 0 (nivel bajo o LOW = 0 V). GPIO2 = 1 (nivel alto o HIGH = 3,3 V = Vcc). Recordemos siempre que el ESP8266 trabaja con niveles l\u00f3gicos de 3,3 V. El pin GPIO2 est\u00e1 por defecto a HIGH, ya que tiene un pull-up interno, por lo que podemos dejarlo simplemente desconectado. Modo de funcionamiento Flash . Para ejecutar un programa en el ESP-01 una vez cargado debemos tener la siguiente configuraci\u00f3n de pines: GPIO0 = 1 GPIO2 = 1 Tanto el GPIO0 como el GPIO2 est\u00e1n por defecto a HIGH, ya que ambos tienen un pull-up interno, por lo que podemos dejarlos simplemente desconectados. En este momento reflexionamos sobre el uso de Rx y Tx ya que si los estamos utilizando para cargar el programa en la placa y GPIO0 y GPIO2 para indicar el modo de trabajo \u00bfc\u00f3mo conectamos los sensores y actuadores al ESP-01?. Veamos: Rx y Tx los utilizamos para cargar el programa. Una vez finalizada la carga los podemos utilizar como pines de entrada y salida digitales. Los modos de trabajo se indican cuando se resetea o reinicia la placa. Una vez que tengamos el modo de ejecuci\u00f3n podemos conectar cualquier componente a estos pines. Los programas los podemos subir a nuestro ESP-01 mediante el IDE de Arduino o por medio de un convertidor USB-serie igual o similar al de la imagen siguiente: conversor USB-serial Se trata de un escudo o shield para el m\u00f3dulo WiFi ESP-01 que est\u00e1 provisto de un chip conversor de USB a puerto serie, en concreto el CH340G. El proceso de reprogramaci\u00f3n con esta placa es bastante sencillo pero requiere de comando AT que pasamos a introducir antes de continuar.","title":"Programaci\u00f3n"},{"location":"IoT_basico/#3-comando-at-en-el-esp8266","text":"El ESP-01 viene por defecto con el firmware AT ai-thinker V0.9.2.4. Los m\u00f3dems ven\u00edan con un conjunto de comandos que permiten que nos podamos comunicar con ellos para configurarlos y que lo podamos hacer a trav\u00e9s del puerto serie de ordenador al que est\u00e1n conectados. A estos comandos se les llama AT (de attention). Despu\u00e9s de cada comando AT, el ESP8266 espera los caracteres especiales de nueva linea para ejecutar el comando. El car\u00e1cter no imprimible CR (del ingl\u00e9s, Carriage Return) significa retorno de carro y LF ( del ingl\u00e9s, Line Feed) es salto de l\u00ednea. El origen de la nomenclatura est\u00e1 en las m\u00e1quinas de escribir. En el enlace tenemos un pdf de la empresa Espressif Systems con el juego de comandos AT para el ESP8266. En la tabla siguiente damos un resumen de los comandos con una informaci\u00f3n ampliada de los que vamos a usar para la configuraci\u00f3n inicial que necesitamos. Unos comandos AT","title":"3.- Comando AT en el ESP8266"},{"location":"IoT_basico/#4-preparacion-del-modulo-esp-01","text":"Primero conectamos el m\u00f3dulo ESP8266 a la shield USB-serie y este a su vez a un puerto USB de nuestro ordenador. Nos aseguramos de que el interruptor est\u00e1 en modo Flash Boot. Entramos en ArduinoBlocks con ArduinoBlocks-Connector en funcionamiento, realizamos un refresco de la lectura del puerto para que detecte a la shield del m\u00f3dulo WiFi si es necesario, abrimos la consola, escogeremos la opci\u00f3n de 115200 en baudrate y tambi\u00e9n la de NL + LF (NL + LF es igual que CR + LF) para comunicarnos con el m\u00f3dulo WiFi. Hacemos clic en Conectar y conectamos la consola, escribimos \u201cAT\u201d en ella y clic en enviar. La situaci\u00f3n es la de la imagen siguiente: Comando AT en consola AB Si todo es correcto debe respondernos \u201cOK\u201d. Si responde algo sin sentido o no contesta, significa que est\u00e1 configurado en alguna otra velocidad. En este segundo caso deberemos cambiar la opci\u00f3n de baudrate y repetir la operaci\u00f3n con diferentes velocidades hasta que nos responda \u201cOK\u201d. La situaci\u00f3n correcta en la consola de comandos es la siguiente: Respuesta al comando AT Una vez que nos responda \u201cOK\u201d, le enviamos el texto \u201cAT+UART_DEF=9600,8,1,0,0\u201d y nos debe responder otra vez \u201cOK\u201d. Comando AT para establecer velocidad a 9600 baudios Con esto hemos cambiado la velocidad a 9600 baudios mediante el comando AT+UART_DEF que nos permite cambiar la definici\u00f3n a 9600 baudios, con 8 bits de datos, 1 bit de parada, sin paridad y sin habilitar el control de flujo. Una vez que hemos configurado el m\u00f3dulo WiFi a la velocidad que nos interesa debemos crear un canal en un servidor MQTT donde enviar los datos y visualizarlos. Esto lo vamos a hacer a trav\u00e9s de la web de Thingspeak , pero antes de nada vamos a describir que es MQTT. Para saber mas acerca de la reprogramaci\u00f3n de la velocidad de comunicaci\u00f3n con ESP8266 visita el enlace: Reprogramar la velocidad de comunicaci\u00f3n del ESP8266 .","title":"4.- Preparaci\u00f3n del m\u00f3dulo ESP-01"},{"location":"IoT_basico/#5-una-introduccion-al-iot-a-traves-de-mqtt","text":"Si queremos trabajar en tareas de IoT debemos de utilizar alg\u00fan protocolo de comunicaci\u00f3n y hoy por hoy el principal es MQTT, pero antes de citar protocolos vamos a tratar algunos conceptos necesarios. Un protocolo de comunicaci\u00f3n no es otra cosa que una serie de normas definidas para que dos o m\u00e1s dispositivos puedan comunicarse entre si de forma comprensible para ambos. Requisitos del IoT Estamos bastante acostumbrados a realizar un tipo de comunicaci\u00f3n denominada M2M (machine-to-machine) utilizando internet, pero cuando trabajamos en IoT debemos establecer una serie de requisitos que hacen que la comunicaci\u00f3n M2M no sea la mas adecuada. Algunos de estos requisitos son: Cantidad: se puede llegar a tener un gran n\u00famero de dispositivos diferentes, desde sensores, actuadores, servidores, etc. Escalabilidad: los sistemas deben permitir a\u00f1adir o eliminar dispositivos sin que el sistema global resulte afectado. Variedad: normalmente necesitaremos que el sistema funcione con diferentes sistemas operativos, lenguajes de programaci\u00f3n y el mayor n\u00famero posible de dispositivos. Simultaneidad: gran cantidad de comunicaciones simultaneas, lo que requiere respuestas r\u00e1pidas para lo que es necesario que los mensajes transmitidos sean lo mas cortos posibles. Seguridad: internet no es un sitio muy seguro y estos dispositivos van a estar conectados a internet controlando dispositivos f\u00edsicos. Accesibilidad: tendremos que trabajar en condiciones muy variadas en lo que se refiere a ancho de banda, firewall, direccionamiento,\u2026 La soluci\u00f3n mas com\u00fan consiste en disponer un servidor denominado \u2018broker\u2019, o a veces \u2018Router\u2019, que ser\u00e1 el que reciba los mensajes de los dispositivos emisores y los distribuir\u00e1 a los receptores. Broker El broker va a tener una direcci\u00f3n IP fija y ser\u00e1 accesible para todos los dispositivos, puede mantener un registro de los dispositivos conectados, recibir y distribuir mensajes y establecer filtros de destinatarios. Esto permite algo fundamental, y es que cada dispositivo no dependa del resto de dispositivos. Veamos algunos conceptos que nos permitan entender las infraestructuras de los servicios IoT: Message Queue o cola de mensajes. En este tipo el broker genera una cola de mensajes \u00fanica para cada uno de los clientes que inician la suscripci\u00f3n. Message Service o servicio de mensajer\u00eda. En este tipo el broker distribuye inmediatamente los mensajes filtrados por alg\u00fan criterio a los clientes conectados. A diferencia de Message Queue, los mensajes entregados mientras el cliente est\u00e1 desconectado se pierden. Publish/Susbcribe (PubSub). Se trata de un sistema de mensajer\u00eda donde el 'Subscriber' informa al broker de que quiere recibir un tipo de mensajes y el 'Publisher' entonces puede publicarlos. Router Remoder Procedure Calls (RRPC). Se trata de la ejecuci\u00f3n remota de procedimientos donde 'Callee' comunica al broker que proporciona un procedimiento y el 'Caller', puede llamar a este procedimiento. Algunos de los protocolos para IoT son: MQTT (del ingl\u00e9s Message Queuing Telemetry Transport) es un protocolo PubSub de servicio de mensajer\u00eda que act\u00faa sobre TCP. Es ligero y f\u00e1cil de implementar resultando apropiado para dispositivos de baja potencia, tan habituales en IoT. TCP es un protocolo de control de transmisi\u00f3n (del ingl\u00e9s, Transmission Control Protocol) fundamental en Internet. AMQP (Advanced Message Queuing Protocol) es un protocolo PubSub de cola de mensajes que asegura la confiabilidad e interoperabilidad necesaria en aplicaciones corporativas. STOMP (Streaming Text Oriented Messaging Protocol). Es un protocolo sencillo que emplea HTTP y mensajes de texto. XMPP (Extensible Messaging and Presence Protocol). Es un protocolo abierto basado en XML dise\u00f1ado para aplicaciones de mensajer\u00eda instant\u00e1nea. WAMP (Web Application Messaging Protocol). Es un protocolo abierto que se ejecuta sobre WebSockets, y provee tanto aplicaciones de PubSub como RRPC. CoAP (Constrained Application Protocol) es un protocolo pensado para emplearse en dispositivos de IoT de baja capacidad. MQTT Dentro de una arquitectura de MQTT, es muy importante el concepto topic (tema en espa\u00f1ol) ya que la comunicaci\u00f3n se realiza a trav\u00e9s de topics debiendo estar los emisores y receptores subscritos a un topic com\u00fan para poder establecer la comunicaci\u00f3n. Este tipo de arquitectura permite que la comunicaci\u00f3n pueda ser de uno a uno o de uno a muchos. Los topics tienen estructura jer\u00e1rquica pudiendo establecer relaciones padre-hijo de manera que cuando nos suscribimos a un topic padre podemos recibir tambi\u00e9n la informaci\u00f3n de sus hijos. En un ejemplo lo podemos ver m\u00e1s claramente. Estructura jerarquica de un topic Un topic se representa mediante una cadena con las jerarquias separadas por /. Por ejemplo: Vivienda/Planta baja/Cocina/Arduino/Luz Vivienda/Planta alta/Dorm.1/Arduino/Temperatura. De esta forma podemos suscribirnos a un topic concreto o a varios, por ejemplo: Un topic: Vivienda/Planta baja/Cocina/Arduino/Luz Varios topics: Vivienda/Planta baja/# Existen b\u00e1sicamente tres tipos de brokers, los privados, los p\u00fablicos y los locales. A continuaci\u00f3n citamos alguno de los m\u00e1s utilizados: a .- Private MQTT Broker: solamente los dispositivos que establezcamos pueden publicar o suscribirse a un topic. Se utiliza en producci\u00f3n y prototipado. Algunos de ellos son: Azure de Microsoft. AWS de Amazon. CloudMQTT disponible en: https://www.cloudmqtt.com/plans.html . ThingSpeak de Mathworks (MATLAB). b .- Public MQTT Broker: cualquier dispositivo puede publicar y suscribirse a topics. Algunos de ellos son: Eclipse Mosquitto HiveMQ: Enlace - Direcci\u00f3n del broker Flespi Dioty Fluux Thingspeak Si queremos instalar nuestro propio broker en una raspberry o PC, sin duda Mosquito es la opci\u00f3n m\u00e1s extendida.","title":"5.- Una introducci\u00f3n al IoT a trav\u00e9s de MQTT"},{"location":"IoT_basico/#6-creacion-de-un-canal-en-un-servidor-mqtt","text":"En nuestro caso vamos a utilizar Thingspeak en su versi\u00f3n p\u00fablica. Lo primero que debemos hacer es crear una cuenta, para lo que clicamos en Sign Up. Seguidamente, introducimos un correo electr\u00f3nico v\u00e1lido y el resto de datos que nos pide. Lo vemos en la imagen siguiente: Pagina inicial de Thingspeaks Debemos aceptar que use la direcci\u00f3n de correo electr\u00f3nico para nuestra cuenta de MathWorks, como se ve en la imagen siguiente: Aceptaci\u00f3n a Mathwork Tras esto recibiremos un correo en la direcci\u00f3n que hemos dado para confirmar la creaci\u00f3n de la cuenta y confirmarla. Debemos ver algo similar a la imagen siguiente: Confirmacion aceptaci\u00f3n cuenta correo Una vez confirmada la direcci\u00f3n de correo electr\u00f3nico, volvemos a la p\u00e1gina donde est\u00e1bamos y hacemos click en continuar. Nos pedir\u00e1 un nombre de usuario y una contrase\u00f1a que usaremos a partir de ahora para iniciar sesi\u00f3n. Finalizada la creaci\u00f3n de la cuenta iniciamos sesi\u00f3n desde la p\u00e1gina principal haciendo clic en \u201cSign In\u201d. Veremos una ventana como la de la imagen siguiente: Ventana para identificaci\u00f3n en Thingspeaks Escribimos nuestra contrase\u00f1a y hacemos clic en el bot\u00f3n Sign in. Acceso a Thingspeaks Con esto entramos en el broker y est\u00e1 todo listo para iniciar el trabajo. Acceso correcto al broker Podemos aprender mas sobre el tema visitando los siguientes enlaces: Primeros pasos con Wifi: Servidor sin clave y contrase\u00f1a Wifi con servidor gratuito con clave y contrase\u00f1a y app m\u00f3vil C\u00f3mo publicar y almacenar datos por Wifi en Internet con Thingspeak","title":"6.- Creaci\u00f3n de un canal en un servidor MQTT"},{"location":"IoT_basico/#7-filtrado-por-mac","text":"Si por cualquier motivo nuestra red WiFi tiene filtrado MAC debemos de dar de alta en la misma de nuestro dispositivo ESP-01. Esta es una tarea que va a depender de nuestro router y suministrador y que no resulta especialmente complicada. Lo primero que debemos hacer es averiguar la direcci\u00f3n MAC de nuestro dispositivo ESP8266. Esta tarea no la vamos a hacer desde ArduinoBlocks sino que vamos a recurrir al IDE de Arduino. Si necesitas ayuda para este tema seguro que la encuentras en estos tutoriales de Luis Llamas , o tambi\u00e9n puedes buscar informaci\u00f3n en tu navegador pues existen multitud de p\u00e1ginas referentes al tema de programaci\u00f3n desde el IDE de Arduino. Los elementos que vamos a utilizar para conectar nuestro m\u00f3dulo ESP-01 a la placa TdR STEAM los vemos en la imagen siguiente: Shield WiFi serial M\u00f3dulo ESP-01 Conector de comunicaciones en la TdR STEAM Cables tipo Dupont M-H Conexionado Nos encontramos con el problema de que el orden de pines en el conector de la TdR STEAM (RX-TX-GND-VCC) no coinicede con el de la Shield WiFi serial (RX-TX-VCC-GND) por lo que no lo vamos a poder \"pinchar\" directamente en el conector y debemos utilizar cables tipo Dupont. Debemos tener muy presente que la placa TdR STEAM ya realiza una conexi\u00f3n cruzada entre los pines Tx y Rx , es decir: Rx de la TdR STEAM va conectada a Tx de la placa UNO Tx de la TdR STEAM va conectada a Rx de la placa UNO En la imagen siguiente vemos gr\u00e1ficamente como debemos hacer el conexionado al que nos estamos refiriendo. Conexi\u00f3n NO CRUZADA TdR - Shield Para nuestro prop\u00f3sito de comunicar el ordenador con el ESP-01 a trav\u00e9s del IDE y averiguar la MAC de nuestro dispositivo creo que lo mas conveniente y claro es realizar el montaje que vemos en la imagen siguiente: Conexi\u00f3n cruzada UNO a Shield wifi En este caso si es totalmente imprescindible realizar la conexi\u00f3n cruzada mostrada en la imagen entre Tx y Rx. Comunicaci\u00f3n entre PC y ESP01 Con la conexi\u00f3n cruzada descrita y un sketch vac\u00edo en el IDE que subimos a la placa UNO, conectamos el UNO al ordenador y establecemos la configuraci\u00f3n de nuestra placa UNO y el puerto USB al que estamos conectados. Lo que en realidad hacemos es usar la placa UNO como un convertidor bidireccional USB a RS232 que nos permite comunicar el ordenador con la placa ESP8266 ESP01. Abrimos el monitor serie desde el IDE de Arduino y lo configuramos como vemos en la imagen siguiente: Configuraci\u00f3n del monitor serie Escribimos AT y pulsamos Enter o hacemos clic en Enviar y el m\u00f3dulo deber\u00e1 responder OK si todo es correcto. Si la velocidad por defecto del m\u00f3dulo no es de 115200 no responder\u00e1 y posiblemente se vean caracteres extra\u00f1os en el monitor serie. En este caso habr\u00e1 que probar distintas velocidades hasta conseguir que el m\u00f3dulo responda OK al comando AT. El resultado correcto lo vemos en la imagen siguiente: Comando AT OK Direcci\u00f3n MAC El \u00faltimo paso es teclear el comando AT para conseguir la direcci\u00f3n f\u00edsica o MAC del dispositivo conectado. Este comando es AT+CIFSR y es que el que vemos en la imagen siguiente: Comando AT para obtener la MAC El comando AT+CIFSR nos devuelve un resultado similar al que vemos en la imagen siguiente: MAC obtenida Ya podemos dar de alta la MAC del dispositivo en nuestro filtrado MAC y poder as\u00ed comunicarnos a trav\u00e9s de WiFi.","title":"7.- Filtrado por MAC"},{"location":"R01/","text":"Reto-01. LED \u00b6 Enunciado \u00b6 Realizar un programa que encienda y apague el LED rojo conectado al pin D12. Teor\u00eda \u00b6 El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energia Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico.","title":"Reto-01. LED"},{"location":"R01/#reto-01-led","text":"","title":"Reto-01. LED"},{"location":"R01/#enunciado","text":"Realizar un programa que encienda y apague el LED rojo conectado al pin D12.","title":"Enunciado"},{"location":"R01/#teoria","text":"El diodo LED (Light Emitting Diode) es un diodo semiconductor capaz de emitir luz, lo mas usuales dentro del espectro visible aunque tambi\u00e9n pueden ser de infrarrojos, laser, etc. Su uso mas habitual es como indicador y, \u00faltimamente cada vez mas frecuentes en iluminaci\u00f3n. Sus principales ventajas frente a luces incandescentes son: Menor consumo de energia Mayor vida \u00fatil Menor tama\u00f1o Gran durabilidad y fiabilidad En la imagen siguiente vemos el aspecto f\u00edsico que tiene y su s\u00edmbolo electr\u00f3nico.","title":"Teor\u00eda"},{"location":"hard/","text":"Hardware TdR STEAM \u00b6 La tabla siguiente es una descripci\u00f3n del hardware TdR-STEAM. Imagen N Sensor, actuador o dispositivo externo Pin de conexi\u00f3n 1 Interface I2C o IIC SDA-A4 y SCL-A5 2 Pulsadores SW1 y SW2 D2 y D7 3 Diodos LED Azul (LED3) y Rojo (LED4) D13 y D12 4 Led RGB o neopixel D6, D9 y D10 5 Dos conectores para Entradas/Salidas digitales D3 y D5 6 Conector de comunicaciones Bluetooth y WiFi (Swich On/Off) Rx y Tx 7 Sensor de Temperatura y Humedad DHT11 D4 8 Potenci\u00f3metro giratorio de 270\u00ba A0 9 Zumbador Piezoel\u00e9ctrico o buzzer D8 10 Diodo receptor de infrarrojos (IR) D11 11 Sensor de luminosidad (LDR) A1 12 Bot\u00f3n de Reset -- 13 Conector para entrada anal\u00f3gica A3 14 Sensor de temperatura (LM35) A2 En la tabla siguiente se establece la relaci\u00f3n entre los elementos de la placa TdR STEAM y las conexiones de una placa UNO. Pin UNO Uso en TdR STEAM Descripci\u00f3n D0 Rx Pin de recepci\u00f3n Bluetooth y WiFi D1 Tx Pin de transmisi\u00f3n Bluetooth y WiFi D2 Pulsador SW1 Entrada digital D3 Conector para entrada/salida digital externa Entrada/salida digital D4 Sensor de Temperatura y Humedad DHT11 Entrada digital D5 Conector para entrada/salida digital externa Entrada/salida digital D6 Color rojo del LED RGB Salida digital D7 Pulsador SW2 Entrada digital D8 Zumbador o buzzer Salida digital D9 Color verde del LED RGB Salida digital D10 Color azul del LED RGB Salida digital D11 Sensor IR Entrada digital D12 LED rojo Salida digital D13 LED azul Salida digital A0 Potenci\u00f3metro Entrada anal\u00f3gica A1 Sensor de luz (LDR) Entrada anal\u00f3gica A2 Sensor de temperatura (LM35) Entrada anal\u00f3gica A3 Conector para entrada anal\u00f3gica externa Entrada anal\u00f3gica A4 SDA (Serial DAta.) Datos I2C A5 SCL (Serial CLock) Se\u00f1al de reloj I2C","title":"Hardware TdR STEAM"},{"location":"hard/#hardware-tdr-steam","text":"La tabla siguiente es una descripci\u00f3n del hardware TdR-STEAM. Imagen N Sensor, actuador o dispositivo externo Pin de conexi\u00f3n 1 Interface I2C o IIC SDA-A4 y SCL-A5 2 Pulsadores SW1 y SW2 D2 y D7 3 Diodos LED Azul (LED3) y Rojo (LED4) D13 y D12 4 Led RGB o neopixel D6, D9 y D10 5 Dos conectores para Entradas/Salidas digitales D3 y D5 6 Conector de comunicaciones Bluetooth y WiFi (Swich On/Off) Rx y Tx 7 Sensor de Temperatura y Humedad DHT11 D4 8 Potenci\u00f3metro giratorio de 270\u00ba A0 9 Zumbador Piezoel\u00e9ctrico o buzzer D8 10 Diodo receptor de infrarrojos (IR) D11 11 Sensor de luminosidad (LDR) A1 12 Bot\u00f3n de Reset -- 13 Conector para entrada anal\u00f3gica A3 14 Sensor de temperatura (LM35) A2 En la tabla siguiente se establece la relaci\u00f3n entre los elementos de la placa TdR STEAM y las conexiones de una placa UNO. Pin UNO Uso en TdR STEAM Descripci\u00f3n D0 Rx Pin de recepci\u00f3n Bluetooth y WiFi D1 Tx Pin de transmisi\u00f3n Bluetooth y WiFi D2 Pulsador SW1 Entrada digital D3 Conector para entrada/salida digital externa Entrada/salida digital D4 Sensor de Temperatura y Humedad DHT11 Entrada digital D5 Conector para entrada/salida digital externa Entrada/salida digital D6 Color rojo del LED RGB Salida digital D7 Pulsador SW2 Entrada digital D8 Zumbador o buzzer Salida digital D9 Color verde del LED RGB Salida digital D10 Color azul del LED RGB Salida digital D11 Sensor IR Entrada digital D12 LED rojo Salida digital D13 LED azul Salida digital A0 Potenci\u00f3metro Entrada anal\u00f3gica A1 Sensor de luz (LDR) Entrada anal\u00f3gica A2 Sensor de temperatura (LM35) Entrada anal\u00f3gica A3 Conector para entrada anal\u00f3gica externa Entrada anal\u00f3gica A4 SDA (Serial DAta.) Datos I2C A5 SCL (Serial CLock) Se\u00f1al de reloj I2C","title":"Hardware TdR STEAM"},{"location":"operadores/","text":"Operadores en programaci\u00f3n C++ \u00b6 \u00bfQue es un operador? \u00b6 En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos. Operadores de asignaci\u00f3n \u00b6 Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a Operadores Aritm\u00e9ticos \u00b6 Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1 Operadores Relacionales o de comparaci\u00f3n \u00b6 Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b Operadores l\u00f3gicos \u00b6 Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores en programaci\u00f3n C++"},{"location":"operadores/#operadores-en-programacion-c","text":"","title":"Operadores en programaci\u00f3n C++"},{"location":"operadores/#que-es-un-operador","text":"En general se puede decir que un operador es un elemento de programa que se aplica a uno o varios operandos en una expresi\u00f3n o instrucci\u00f3n. Existen muchos tipos de operadores y nosotros vamos a mostrar aqu\u00ed solamente algunos de los mas utilizados. Los mostraremos por tipos como sistema para clasificarlos.","title":"\u00bfQue es un operador?"},{"location":"operadores/#operadores-de-asignacion","text":"Sirven para asignar un valor especifico a una variable mediante asignaci\u00f3n simple o por dos operadores. En la tabla siguiente vemos algunos de estos operadores: Operador Nombre Sintaxis = Asignaci\u00f3n a = b += Suma y asignaci\u00f3n a += b; a = a + b -= Resta y asignaci\u00f3n a -= b; a = a - b *= Multiplicaci\u00f3n y asignaci\u00f3n a *= b; a = a * b /= Divisi\u00f3n y asignaci\u00f3n a /= b; a = a / b ++ Posincremento o preincremento a++ ; ++a -- Posdecremento o predecremento a-- ; --a","title":"Operadores de asignaci\u00f3n"},{"location":"operadores/#operadores-aritmeticos","text":"Nos permiten hacer operaciones o c\u00e1lculos simples. Los vemos en la tabla siguiente: Operador Nombre Sintaxis + Suma a + b - Resta a - b * Multiplicaci\u00f3n a * b / Divisi\u00f3n a / b % M\u00f3dulo o resto de divisi\u00f3n a % b ++ Incremento en 1 a++; a = a+1 -- Decremento en 1 a--; a = a-1","title":"Operadores Aritm\u00e9ticos"},{"location":"operadores/#operadores-relacionales-o-de-comparacion","text":"Sirven para comparar dos variables o expresiones o bien probar la veracidad de una condici\u00f3n. La respuesta es tipo booleano (falso = 0 y verdadero = 1). Los vemos en la tabla siguiente: Operador Nombre Sintaxis < Menor que a < b > Mayor que a > b <= Menor o igual que a <= b <= Mayor o igual que a >= b == Igual a == b != Distinto a != b","title":"Operadores Relacionales o de comparaci\u00f3n"},{"location":"operadores/#operadores-logicos","text":"Siempre generan un resultado de tipo booleano y se corresponden con la idea de funcionamiento de las tablas de verdad de la puertas l\u00f3gicas elementales. En la tabla siguiente se dan las tablas de verdad y los operadores. a b AND OR NOT a NOT b Operador Nombre Sintaxis 0 0 0 0 1 1 0 1 0 1 1 0 && Y l\u00f3gico-AND a&&b 1 0 0 1 0 1 1 1 1 1 0 0 ! Negaci\u00f3n l\u00f3gica-NOT !a Existen otros muchos operadores que se pueden consultar en la web.","title":"Operadores l\u00f3gicos"},{"location":"soft/","text":"Software \u00b6 Vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"Software"},{"location":"soft/#software","text":"Vamos a utilizar el lenguaje de programaci\u00f3n visual por bloques denominado ArduinoBlocks. El aspecto de la plataforma al entrar lo vemos en la imagen siguiente: Portada de la plataforma ArduinoBlocks Podemos programar nuestra placa de control tipo UNO de diversas formas de las que las mas comunes son, a partir del IDE de Arduino o mediante bloques, que ser\u00e1 el m\u00e9todo que sigamos. Programar mediante el IDE requiere teclear instrucciones de c\u00f3digo mientras que con ArduinoBlocks estas instrucciones se sustituyen por bloques tipo puzzle que evitan errores de sintaxis. Evidentemente detr\u00e1s de cada bloque en realidad lo que hay son instrucciones y ArduinoBlocks nos va a permitir verlas y exportarlas. En la imagen siguiente tenemos una comparativa entre bloques de c\u00f3digo e instrucciones en el IDE. Comparativa entre bloques y c\u00f3digo Es importante entender que la programaci\u00f3n con ArduinoBlocks simplifica la iniciaci\u00f3n en el pensamiento computacional permitiendo realizar tareas complejas de una forma sencilla. Para el caso de la TdR STEAM cabe destacar que ArduinoBlocks incluye una serie de bloques espec\u00edficos que facilitan a\u00fan mas si cabe su programaci\u00f3n. ArduinoBlocks trabaja a trav\u00e9s de una plataforma online por lo que no requiere instalaci\u00f3n en nuestro sistema. No obstante, si que tenemos que instalar un peque\u00f1o programa que ser\u00e1 el encargado de conectar nuestro programa en el navegador con la placa Keyestudio UNO. Este programa basado en Python se llama Connector . Lo primero que deberemos hacer es crear una cuenta en ArduinoBlocks utilizando una direcci\u00f3n de correo electr\u00f3nico v\u00e1lida y despu\u00e9s instalar el software Connector . En los manuales de referencia disponibles en la plataforma est\u00e1n todos los detalles sobre como llevar a cabo estas tareas. La versi\u00f3n 5 del programa una vez iniciado la vemos en la imagen siguiente: Connector V5 Si no est\u00e1s muy avezado en estos temas es necesarios al menos ver los siguientes v\u00eddeos sobre el tema: Bloque 1: Puesta en marcha con ArduinoBlocks Empezando con ArduinoBlocks y la programaci\u00f3n por bloques Crear una cuenta en ArduinoBlocks e iniciar un proyecto personal Configurar la conexi\u00f3n a ArduinoBlocks y detectar la placa Arduino Carga del primer programa","title":"Software"},{"location":"Miscelanea/about/","text":"Autor \u00b6 Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/about/#autor","text":"Federico Coca GitHub Twitter Instagram Mas informaci\u00f3n","title":"Autor"},{"location":"Miscelanea/lic/","text":"Licencias \u00b6 Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/lic/#licencias","text":"Licencia MIT incluida en la creaci\u00f3n del repositorio. Creative Commons Atribuci\u00f3n-CompartirIgual 4.0 International (\"CC BY-SA\"). CC BY-SA 4.0","title":"Licencias"},{"location":"Miscelanea/soft/","text":"Software utilizado \u00b6 Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP ArduinoBlocks ArduinoBlocks Connector","title":"Software utilizado"},{"location":"Miscelanea/soft/#software-utilizado","text":"Dibujo 3D FreeCAD 0.19 Sistema operativo principal: Ubuntu 20.04.4 LTS (Focal Fossa) Paquete ofim\u00e1tico de referencia: LibreOffice Libreria Material para MkDocs Visual Studio Code Creaci\u00f3n de GIF animados para Ubuntu Peek Sistema principal de capturas de pantalla: Shutter 0.94 Dibujo 2D vectorial Inkscape Retoque de im\u00e1genes GIMP ArduinoBlocks ArduinoBlocks Connector","title":"Software utilizado"},{"location":"Miscelanea/webgrafia/","text":"Webgraf\u00eda y bibliograf\u00eda \u00b6 ArduinoBlocks - FreeBook (online & updated) Wikipedia Retos con Imagina TdR STEAM","title":"Webgrafia/Bibliograf\u00eda"},{"location":"Miscelanea/webgrafia/#webgrafia-y-bibliografia","text":"ArduinoBlocks - FreeBook (online & updated) Wikipedia Retos con Imagina TdR STEAM","title":"Webgraf\u00eda y bibliograf\u00eda"}]}